////////////////////////////////////////////////////////////////////////
//FAKE関数

//FAKE_VALUE_FUNC(int, external_function, int);

////////////////////////////////////////////////////////////////////////

class tx: public testing::Test {
protected:
    virtual void SetUp() {
        //RESET_FAKE(external_function)
        ptarm_init(PTARM_TESTNET, false);
    }

    virtual void TearDown() {
        ASSERT_EQ(0, ptarm_dbg_malloc_cnt());
        ptarm_term();
    }

public:
    static void DumpBin(const uint8_t *pData, uint16_t Len)
    {
        for (uint16_t lp = 0; lp < Len; lp++) {
            printf("%02x", pData[lp]);
        }
        printf("\n");
    }
};

////////////////////////////////////////////////////////////////////////

TEST_F(tx, init)
{
    ptarm_tx_t tx;

    memset(&tx, 0xff, sizeof(tx));

    ptarm_tx_init(&tx);

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(0, tx.vin_cnt);
    ASSERT_TRUE(NULL == tx.vin);
    ASSERT_EQ(0, tx.vout_cnt);
    ASSERT_TRUE(NULL == tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ptarm_print_tx(&tx);
}


TEST_F(tx, add_vin1)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    const uint8_t TXID_LE[] = {
        0x30, 0xfa, 0xe6, 0xf6, 0xc7, 0x17, 0xa6, 0x91,
        0xa7, 0x6b, 0x3d, 0x8d, 0xa0, 0x54, 0x64, 0xe5,
        0x73, 0xc9, 0x3d, 0x28, 0x62, 0xa1, 0x4b, 0x61,
        0x8a, 0xa7, 0xe0, 0x03, 0x2b, 0x87, 0xbe, 0x2e,
    };
    ptarm_vin_t *vin;
    ptarm_tx_add_vin(&tx, TXID_LE, 2);
    vin = &tx.vin[0];

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_TRUE(NULL != tx.vin);
    ASSERT_EQ(0, tx.vout_cnt);
    ASSERT_TRUE(NULL == tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ASSERT_TRUE(&tx.vin[0] == vin);
    ASSERT_EQ(0, memcmp(vin->txid, TXID_LE, sizeof(TXID_LE)));
    ASSERT_EQ(2, vin->index);
    ASSERT_TRUE(NULL == vin->script.buf);
    ASSERT_EQ(0, vin->script.len);
    ASSERT_EQ(0, vin->wit_cnt);
    ASSERT_TRUE(NULL == vin->witness);
    ASSERT_EQ(0xffffffff, vin->sequence);

    //wit
    ptarm_buf_t *wit1 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(1, vin->wit_cnt);
    ASSERT_TRUE(wit1 == &vin->witness[0]);
    ASSERT_EQ(0, wit1->len);
    ASSERT_TRUE(NULL == wit1->buf);
    const uint8_t WIT1[] = { 1, 2, 3 };
    ptarm_buf_alloccopy(wit1, WIT1, sizeof(WIT1));

    ptarm_buf_t *wit2 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(2, vin->wit_cnt);
    ASSERT_TRUE(wit2 == &vin->witness[1]);
    ASSERT_EQ(0, wit2->len);
    ASSERT_TRUE(NULL == wit2->buf);
    const uint8_t WIT2[] = { 5, 6, 7, 8, 9 };
    ptarm_buf_alloccopy(wit2, WIT2, sizeof(WIT2));

    ASSERT_EQ(0, memcmp(WIT1, vin->witness[0].buf, sizeof(WIT1)));
    ASSERT_EQ(sizeof(WIT1), vin->witness[0].len);
    ASSERT_EQ(0, memcmp(WIT2, vin->witness[1].buf, sizeof(WIT2)));
    ASSERT_EQ(sizeof(WIT2), vin->witness[1].len);

    ptarm_print_tx(&tx);
    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vin2)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //vin
    //2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    const uint8_t TXID_LE[] = {
        0x30, 0xfa, 0xe6, 0xf6, 0xc7, 0x17, 0xa6, 0x91,
        0xa7, 0x6b, 0x3d, 0x8d, 0xa0, 0x54, 0x64, 0xe5,
        0x73, 0xc9, 0x3d, 0x28, 0x62, 0xa1, 0x4b, 0x61,
        0x8a, 0xa7, 0xe0, 0x03, 0x2b, 0x87, 0xbe, 0x2e,
    };
    ptarm_vin_t *vin;
    ptarm_tx_add_vin(&tx, TXID_LE, 2);
    vin = &tx.vin[0];

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_TRUE(NULL != tx.vin);
    ASSERT_EQ(0, tx.vout_cnt);
    ASSERT_TRUE(NULL == tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ASSERT_EQ(0, memcmp(vin->txid, TXID_LE, sizeof(TXID_LE)));
    ASSERT_EQ(2, vin->index);
    ASSERT_TRUE(NULL == vin->script.buf);
    ASSERT_EQ(0, vin->script.len);
    ASSERT_EQ(0, vin->wit_cnt);
    ASSERT_TRUE(NULL == vin->witness);
    ASSERT_EQ(0xffffffff, vin->sequence);

    //wit
    ptarm_buf_t *wit01 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(1, vin->wit_cnt);
    ASSERT_TRUE(wit01 == &vin->witness[0]);
    ASSERT_EQ(0, wit01->len);
    ASSERT_TRUE(NULL == wit01->buf);
    const uint8_t WIT01[] = { 1, 2, 3 };
    ptarm_buf_alloccopy(wit01, WIT01, sizeof(WIT01));

    ptarm_buf_t *wit02 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(2, vin->wit_cnt);
    ASSERT_TRUE(wit02 == &vin->witness[1]);
    ASSERT_EQ(0, wit02->len);
    ASSERT_TRUE(NULL == wit02->buf);
    const uint8_t WIT02[] = { 5, 6, 7, 8, 9 };
    ptarm_buf_alloccopy(wit02, WIT02, sizeof(WIT02));

    //vin
    //03dae0bff963e1dca328b43c703f2db5a344ef1b6e1eb6b6a7782328c8199ee4
    const uint8_t TXID2_LE[] = {
        0xe4, 0x9e, 0x19, 0xc8, 0x28, 0x23, 0x78, 0xa7,
        0xb6, 0xb6, 0x1e, 0x6e, 0x1b, 0xef, 0x44, 0xa3,
        0xb5, 0x2d, 0x3f, 0x70, 0x3c, 0xb4, 0x28, 0xa3,
        0xdc, 0xe1, 0x63, 0xf9, 0xbf, 0xe0, 0xda, 0x03,
    };
    ptarm_tx_add_vin(&tx, TXID2_LE, 5);
    vin = &tx.vin[1];

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(2, tx.vin_cnt);
    ASSERT_TRUE(NULL != tx.vin);
    ASSERT_EQ(0, tx.vout_cnt);
    ASSERT_TRUE(NULL == tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ASSERT_EQ(0, memcmp(vin->txid, TXID2_LE, sizeof(TXID2_LE)));
    ASSERT_EQ(5, vin->index);
    ASSERT_TRUE(NULL == vin->script.buf);
    ASSERT_EQ(0, vin->script.len);
    ASSERT_EQ(0, vin->wit_cnt);
    ASSERT_TRUE(NULL == vin->witness);
    ASSERT_EQ(0xffffffff, vin->sequence);

    //wit
    ptarm_buf_t *wit11 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(1, vin->wit_cnt);
    ASSERT_TRUE(wit11 == &vin->witness[0]);
    ASSERT_EQ(0, wit11->len);
    ASSERT_TRUE(NULL == wit11->buf);
    const uint8_t WIT11[] = { 10, 11 };
    ptarm_buf_alloccopy(wit11, WIT11, sizeof(WIT11));

    ptarm_buf_t *wit12 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(2, vin->wit_cnt);
    ASSERT_TRUE(wit12 == &vin->witness[1]);
    ASSERT_EQ(0, wit12->len);
    ASSERT_TRUE(NULL == wit12->buf);
    const uint8_t WIT12[] = { 12, 13, 14 };
    ptarm_buf_alloccopy(wit12, WIT12, sizeof(WIT12));

    ptarm_buf_t *wit13 = ptarm_tx_add_wit(vin);
    ASSERT_EQ(3, vin->wit_cnt);
    ASSERT_TRUE(wit13 == &vin->witness[2]);
    ASSERT_EQ(0, wit13->len);
    ASSERT_TRUE(NULL == wit13->buf);
    const uint8_t WIT13[] = { 3, 16, 17, 18 };
    ptarm_buf_alloccopy(wit13, WIT13, sizeof(WIT13));


    ASSERT_EQ(0, memcmp(WIT01, tx.vin[0].witness[0].buf, sizeof(WIT01)));
    ASSERT_EQ(sizeof(WIT01), tx.vin[0].witness[0].len);
    ASSERT_EQ(0, memcmp(WIT02, tx.vin[0].witness[1].buf, sizeof(WIT02)));
    ASSERT_EQ(sizeof(WIT02), tx.vin[0].witness[1].len);
    ASSERT_EQ(0, memcmp(WIT11, tx.vin[1].witness[0].buf, sizeof(WIT11)));
    ASSERT_EQ(sizeof(WIT11), tx.vin[1].witness[0].len);
    ASSERT_EQ(0, memcmp(WIT12, tx.vin[1].witness[1].buf, sizeof(WIT12)));
    ASSERT_EQ(sizeof(WIT12), tx.vin[1].witness[1].len);
    ASSERT_EQ(0, memcmp(WIT13, tx.vin[1].witness[2].buf, sizeof(WIT13)));
    ASSERT_EQ(sizeof(WIT13), tx.vin[1].witness[2].len);

    ptarm_print_tx(&tx);
    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vin_vinmax)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //今回はvarint型で1byte分までしか対応しないつもりだったが、そうもいかなくなった
    tx.vin_cnt = 0xfc;      //既に0xfcある

    //2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    const uint8_t TXID_LE[] = {
        0x30, 0xfa, 0xe6, 0xf6, 0xc7, 0x17, 0xa6, 0x91,
        0xa7, 0x6b, 0x3d, 0x8d, 0xa0, 0x54, 0x64, 0xe5,
        0x73, 0xc9, 0x3d, 0x28, 0x62, 0xa1, 0x4b, 0x61,
        0x8a, 0xa7, 0xe0, 0x03, 0x2b, 0x87, 0xbe, 0x2e,
    };
    ptarm_tx_add_vin(&tx, TXID_LE, 2);
    ASSERT_EQ(0xfd, tx.vin_cnt);        //追加OK

    //vin_cntを操作したので、解放できるよう変更
    tx.vin_cnt = 1;
    tx.vin[0].wit_cnt = 0;
    tx.vin[0].script.len = 0;
    tx.vin[0].script.buf = NULL;
    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vin_witmax)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    const uint8_t TXID_LE[] = {
        0x30, 0xfa, 0xe6, 0xf6, 0xc7, 0x17, 0xa6, 0x91,
        0xa7, 0x6b, 0x3d, 0x8d, 0xa0, 0x54, 0x64, 0xe5,
        0x73, 0xc9, 0x3d, 0x28, 0x62, 0xa1, 0x4b, 0x61,
        0x8a, 0xa7, 0xe0, 0x03, 0x2b, 0x87, 0xbe, 0x2e,
    };
    ptarm_tx_add_vin(&tx, TXID_LE, 2);
    //今回はvarint型で1byte分までしか対応しないつもりだったが、そうもいかなくなった
    ptarm_vin_t *vin = &tx.vin[0];
    vin->wit_cnt = 0xfc;

    ptarm_buf_t *wit = ptarm_tx_add_wit(vin);
    ASSERT_TRUE(wit != NULL);
    ASSERT_EQ(0xfd, vin->wit_cnt);

    //tx_freeのために初期化
    for (uint32_t lp2 = 0; lp2 < vin->wit_cnt; lp2++) {
        ptarm_buf_init(&(vin->witness[lp2]));
    }
    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout1)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    ptarm_vout_t *vout = ptarm_tx_add_vout(&tx, (uint64_t)0x123456789abcdef0);

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(0, tx.vin_cnt);
    ASSERT_TRUE(NULL == tx.vin);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ASSERT_TRUE(&tx.vout[0] == vout);
    ASSERT_EQ((uint64_t)0x123456789abcdef0, vout->value);
    ASSERT_EQ(0, vout->script.len);
    ASSERT_TRUE(NULL == vout->script.buf);

    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout2)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //vout0
    ptarm_vout_t *vout0 = ptarm_tx_add_vout(&tx, (uint64_t)0x123456789abcdef0);

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(0, tx.vin_cnt);
    ASSERT_TRUE(NULL == tx.vin);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ASSERT_TRUE(&tx.vout[0] == vout0);
    ASSERT_EQ((uint64_t)0x123456789abcdef0, vout0->value);
    ASSERT_EQ(0, vout0->script.len);
    ASSERT_TRUE(NULL == vout0->script.buf);

    const uint8_t VOUT0[] = { 1, 3, 5, 7 };
    ptarm_buf_alloccopy(&vout0->script, VOUT0, sizeof(VOUT0));

    //vout1
    ptarm_vout_t *vout1 = ptarm_tx_add_vout(&tx, (uint64_t)0x9abcdef012345678);

    ASSERT_EQ(2, tx.version);
    ASSERT_EQ(0, tx.vin_cnt);
    ASSERT_TRUE(NULL == tx.vin);
    ASSERT_EQ(2, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout);
    ASSERT_EQ(0, tx.locktime);

    ASSERT_TRUE(&tx.vout[1] == vout1);
    ASSERT_EQ((uint64_t)0x9abcdef012345678, vout1->value);
    ASSERT_EQ(0, vout1->script.len);
    ASSERT_TRUE(NULL == vout1->script.buf);

    const uint8_t VOUT1[] = { 2, 4, 6, 8, 10 };
    ptarm_buf_alloccopy(&vout1->script, VOUT1, sizeof(VOUT1));

    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout_max)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //今回はvarint型で1byte分までしか対応しない、というわけにもいかなくなった
    tx.vout_cnt = 0xfc;      //既に0xfcある

    ptarm_vout_t *vout0 = ptarm_tx_add_vout(&tx, (uint64_t)0x123456789abcdef0);
    ASSERT_TRUE(vout0 != NULL);
    ASSERT_EQ(0xfd, tx.vout_cnt);

    for (int lp = 0; lp < tx.vout_cnt; lp++) {
        ptarm_buf_init(&tx.vout[lp].script);
    }
    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout_p2pkh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //mwJyBWTEUYMdJ12JWwK3eXff48pxQU6685
    const uint8_t PKH[PTARM_SZ_PUBKEYHASH] = {
        0xad, 0x3d, 0xc2, 0xf5, 0x22, 0x96, 0xf9, 0x3c,
        0x78, 0x98, 0xeb, 0x63, 0x8b, 0x0d, 0x74, 0xf2,
        0x7d, 0x79, 0xef, 0xc3,
    };
    const uint8_t SPK[] = {
        0x76, 0xa9, 0x14, 0xad, 0x3d, 0xc2, 0xf5, 0x22,
        0x96, 0xf9, 0x3c, 0x78, 0x98, 0xeb, 0x63, 0x8b,
        0x0d, 0x74, 0xf2, 0x7d, 0x79, 0xef, 0xc3, 0x88,
        0xac,
    };

    bool ret = ptarm_tx_add_vout_p2pkh(&tx, (uint64_t)0x9abcdef012345678, PKH);
    ASSERT_TRUE(ret);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout[0].script.buf);
    ASSERT_EQ(0, memcmp(SPK, tx.vout[0].script.buf, sizeof(SPK)));
    ASSERT_EQ(sizeof(SPK), tx.vout[0].script.len);
    ASSERT_EQ((uint64_t)0x9abcdef012345678, tx.vout[0].value);

    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout_p2pkh_addr)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    const char ADDR[] = "mwJyBWTEUYMdJ12JWwK3eXff48pxQU6685";
    const uint8_t SPK[] = {
        0x76, 0xa9, 0x14, 0xad, 0x3d, 0xc2, 0xf5, 0x22,
        0x96, 0xf9, 0x3c, 0x78, 0x98, 0xeb, 0x63, 0x8b,
        0x0d, 0x74, 0xf2, 0x7d, 0x79, 0xef, 0xc3, 0x88,
        0xac,
    };

    bool ret = ptarm_tx_add_vout_p2pkh_addr(&tx, (uint64_t)0x9abcdef012345678, ADDR);
    ASSERT_TRUE(ret);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout[0].script.buf);
    ASSERT_EQ(0, memcmp(SPK, tx.vout[0].script.buf, sizeof(SPK)));
    ASSERT_EQ(sizeof(SPK), tx.vout[0].script.len);
    ASSERT_EQ((uint64_t)0x9abcdef012345678, tx.vout[0].value);

    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout_p2sh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //522103240bc79a6479851abe776465500a9ff2f880940b227bfcbcb6d479886a318fa02103921b524e16b81c813baf062a2844ff6842073cc0ec609231a0e33700dd24b5f3210329bd4a08250b6aef97581b36412c9be28c84bab77d7a518a88003a180afcfcdc53ae
    //2NFV4cU7qnrXo5xtbtoQ6zPwyFzdGmzbHzT
    const uint8_t PKH[PTARM_SZ_PUBKEYHASH] = {
        0xf3, 0xf0, 0xc3, 0x8f, 0x7f, 0x4b, 0xa7, 0x02,
        0x5d, 0xd7, 0x83, 0xad, 0xc3, 0x67, 0x4f, 0xa6,
        0x5b, 0x2d, 0x55, 0xbf,
    };
    const uint8_t SPK[] = {
        0xa9, 0x14, 0xf3, 0xf0, 0xc3, 0x8f, 0x7f, 0x4b,
        0xa7, 0x02, 0x5d, 0xd7, 0x83, 0xad, 0xc3, 0x67,
        0x4f, 0xa6, 0x5b, 0x2d, 0x55, 0xbf, 0x87,
    };

    bool ret = ptarm_tx_add_vout_p2sh(&tx, (uint64_t)0x9abcdef012345678, PKH);
    ASSERT_TRUE(ret);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout[0].script.buf);
    ASSERT_EQ(0, memcmp(SPK, tx.vout[0].script.buf, sizeof(SPK)));
    ASSERT_EQ(sizeof(SPK), tx.vout[0].script.len);
    ASSERT_EQ((uint64_t)0x9abcdef012345678, tx.vout[0].value);

    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout_p2sh_addr)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //522103240bc79a6479851abe776465500a9ff2f880940b227bfcbcb6d479886a318fa02103921b524e16b81c813baf062a2844ff6842073cc0ec609231a0e33700dd24b5f3210329bd4a08250b6aef97581b36412c9be28c84bab77d7a518a88003a180afcfcdc53ae
    //2NFV4cU7qnrXo5xtbtoQ6zPwyFzdGmzbHzT
    const char ADDR[] = "2NFV4cU7qnrXo5xtbtoQ6zPwyFzdGmzbHzT";
    const uint8_t SPK[] = {
        0xa9, 0x14, 0xf3, 0xf0, 0xc3, 0x8f, 0x7f, 0x4b,
        0xa7, 0x02, 0x5d, 0xd7, 0x83, 0xad, 0xc3, 0x67,
        0x4f, 0xa6, 0x5b, 0x2d, 0x55, 0xbf, 0x87,
    };

    bool ret = ptarm_tx_add_vout_p2sh_addr(&tx, (uint64_t)0x9abcdef012345678, ADDR);
    ASSERT_TRUE(ret);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout[0].script.buf);
    ASSERT_EQ(0, memcmp(SPK, tx.vout[0].script.buf, sizeof(SPK)));
    ASSERT_EQ(sizeof(SPK), tx.vout[0].script.len);
    ASSERT_EQ((uint64_t)0x9abcdef012345678, tx.vout[0].value);

    ptarm_tx_free(&tx);
}


TEST_F(tx, add_vout_p2sh_redeem)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //522103240bc79a6479851abe776465500a9ff2f880940b227bfcbcb6d479886a318fa02103921b524e16b81c813baf062a2844ff6842073cc0ec609231a0e33700dd24b5f3210329bd4a08250b6aef97581b36412c9be28c84bab77d7a518a88003a180afcfcdc53ae
    //2NFV4cU7qnrXo5xtbtoQ6zPwyFzdGmzbHzT
    const uint8_t REDEEM[] = {
        0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64,
        0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50,
        0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22,
        0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a,
        0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b, 0x52,
        0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf, 0x06,
        0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07, 0x3c,
        0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3, 0x37,
        0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03, 0x29,
        0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef, 0x97,
        0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2, 0x8c,
        0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a, 0x88,
        0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc, 0x53,
        0xae,
    };
    const ptarm_buf_t redeem = { (uint8_t *)REDEEM, sizeof(REDEEM) };
    const uint8_t SPK[] = {
        0xa9, 0x14, 0xf3, 0xf0, 0xc3, 0x8f, 0x7f, 0x4b,
        0xa7, 0x02, 0x5d, 0xd7, 0x83, 0xad, 0xc3, 0x67,
        0x4f, 0xa6, 0x5b, 0x2d, 0x55, 0xbf, 0x87,
    };

    bool ret = ptarm_tx_add_vout_p2sh_redeem(&tx, (uint64_t)0x9abcdef012345678, &redeem);
    ASSERT_TRUE(ret);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout[0].script.buf);
    ASSERT_EQ(0, memcmp(SPK, tx.vout[0].script.buf, sizeof(SPK)));
    ASSERT_EQ(sizeof(SPK), tx.vout[0].script.len);
    ASSERT_EQ((uint64_t)0x9abcdef012345678, tx.vout[0].value);

    ptarm_tx_free(&tx);
}


TEST_F(tx, script_p2pkh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //トランザクション:2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30

    const uint8_t TXID[] = {
        0xe5, 0xbf, 0x81, 0x02, 0x0b, 0x6d, 0xb2, 0xb4,
        0xd3, 0x56, 0xc4, 0xa6, 0xf8, 0xb2, 0xa7, 0xb0,
        0x4b, 0xf9, 0x0e, 0xfd, 0x2a, 0xc3, 0x0c, 0x6e,
        0x35, 0xcb, 0xd0, 0x0a, 0x51, 0x6b, 0xe4, 0x4c,
    };
    ptarm_tx_add_vin(&tx, TXID, 1);
    const uint8_t SIG[] = {
        0x30, 0x44, 0x02, 0x20, 0x04, 0x7c, 0x1b, 0x11,
        0x11, 0xbb, 0xe0, 0xfc, 0x09, 0xcf, 0x2e, 0xd2,
        0x8d, 0xd1, 0xab, 0xd6, 0x13, 0xc0, 0x2b, 0x74,
        0x7a, 0xf8, 0xed, 0xd1, 0x27, 0x48, 0x86, 0x65,
        0x42, 0x59, 0xbb, 0xfb, 0x02, 0x20, 0x1d, 0x00,
        0xca, 0x3f, 0xc1, 0x0a, 0x11, 0x1a, 0x5a, 0x3e,
        0xa0, 0x66, 0x99, 0x92, 0xe4, 0xad, 0x9a, 0x2f,
        0x1c, 0x40, 0x2e, 0xc5, 0xfd, 0x29, 0xd9, 0xe1,
        0x34, 0x8a, 0xb0, 0x58, 0x4f, 0xa2, 0x01,
    };
    const ptarm_buf_t sig = { (uint8_t *)SIG, sizeof(SIG) };
    const uint8_t PUB[] = {
        0x03, 0xbe, 0xce, 0xc4, 0x1f, 0x68, 0xd7, 0x7f,
        0xde, 0x9e, 0x97, 0x2c, 0x79, 0xaa, 0x0e, 0x6e,
        0x4e, 0x81, 0x8b, 0xd3, 0x04, 0x62, 0x76, 0x96,
        0x9e, 0x79, 0x37, 0x4e, 0xc0, 0x56, 0x1b, 0xa4,
        0x59,
    };
    const uint8_t SCRIPTSIG[] = {
        0x47, 0x30, 0x44, 0x02, 0x20, 0x04, 0x7c, 0x1b,
        0x11, 0x11, 0xbb, 0xe0, 0xfc, 0x09, 0xcf, 0x2e,
        0xd2, 0x8d, 0xd1, 0xab, 0xd6, 0x13, 0xc0, 0x2b,
        0x74, 0x7a, 0xf8, 0xed, 0xd1, 0x27, 0x48, 0x86,
        0x65, 0x42, 0x59, 0xbb, 0xfb, 0x02, 0x20, 0x1d,
        0x00, 0xca, 0x3f, 0xc1, 0x0a, 0x11, 0x1a, 0x5a,
        0x3e, 0xa0, 0x66, 0x99, 0x92, 0xe4, 0xad, 0x9a,
        0x2f, 0x1c, 0x40, 0x2e, 0xc5, 0xfd, 0x29, 0xd9,
        0xe1, 0x34, 0x8a, 0xb0, 0x58, 0x4f, 0xa2, 0x01,
        0x21, 0x03, 0xbe, 0xce, 0xc4, 0x1f, 0x68, 0xd7,
        0x7f, 0xde, 0x9e, 0x97, 0x2c, 0x79, 0xaa, 0x0e,
        0x6e, 0x4e, 0x81, 0x8b, 0xd3, 0x04, 0x62, 0x76,
        0x96, 0x9e, 0x79, 0x37, 0x4e, 0xc0, 0x56, 0x1b,
        0xa4, 0x59,
    };

    bool ret = ptarm_tx_set_vin_p2pkh(&tx, 0, &sig, PUB);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(SCRIPTSIG, tx.vin[0].script.buf, sizeof(SCRIPTSIG)));
    ASSERT_EQ(sizeof(SCRIPTSIG), tx.vin[0].script.len);

    ptarm_tx_free(&tx);
}


TEST_F(tx, script_p2sh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //トランザクション:7359a2e1c945d1daf8ead20f51f74508ce8b463261643931b17b8099d0f2090c

    const uint8_t TXID[] = {
        0x33, 0x69, 0xbf, 0xb4, 0xb5, 0x62, 0xe9, 0x10,
        0xb0, 0xee, 0xb9, 0x6e, 0x8f, 0x1d, 0x0f, 0xfb,
        0x97, 0xec, 0x2d, 0xe4, 0x8a, 0x3c, 0x1e, 0x41,
        0x51, 0xac, 0xa6, 0xda, 0xf0, 0x6c, 0x84, 0x89,
    };
    ptarm_tx_add_vin(&tx, TXID, 0);
    const uint8_t SIG1[] = {
        0x30, 0x45, 0x02, 0x21, 0x00, 0xd1, 0x8a, 0xc1,
        0x9e, 0x45, 0x57, 0xe0, 0x25, 0xaa, 0x90, 0x0b,
        0xc8, 0x01, 0x77, 0x98, 0x71, 0xb8, 0x30, 0x98,
        0x74, 0xc2, 0xe6, 0x2c, 0x9f, 0x84, 0x7f, 0xb0,
        0xe5, 0xfd, 0x6b, 0xbd, 0x8c, 0x02, 0x20, 0x21,
        0xe7, 0x40, 0x2c, 0x83, 0x3f, 0x95, 0x49, 0x02,
        0x3d, 0x11, 0x82, 0xa9, 0xae, 0x70, 0x8b, 0x1a,
        0x6d, 0xb5, 0xbc, 0x03, 0x83, 0xf0, 0xb5, 0x52,
        0x9d, 0xde, 0xaa, 0xec, 0x08, 0x3f, 0x02, 0x01,
    };
    const ptarm_buf_t sig1 = { (uint8_t *)SIG1, sizeof(SIG1) };
    const uint8_t SIG2[] = {
        0x30, 0x45, 0x02, 0x21, 0x00, 0xe1, 0x1f, 0xd5,
        0xcc, 0xf8, 0x8d, 0x90, 0x16, 0x57, 0xb3, 0xce,
        0x08, 0xbb, 0xa6, 0x3d, 0xdc, 0x9a, 0x18, 0xd3,
        0x02, 0xcc, 0xc3, 0x9c, 0xb1, 0x2e, 0xca, 0xa0,
        0x25, 0xaa, 0x2b, 0x82, 0x79, 0x02, 0x20, 0x5d,
        0x3a, 0xad, 0xc5, 0xd1, 0x04, 0x7b, 0xe1, 0x48,
        0x44, 0x04, 0xf3, 0x49, 0x2b, 0xcf, 0x8f, 0x63,
        0x2c, 0x75, 0xcd, 0x14, 0x6a, 0xe8, 0xd8, 0x3f,
        0x0d, 0x99, 0x1e, 0x21, 0xc6, 0x97, 0xd2, 0x01,
    };
    const ptarm_buf_t sig2 = { (uint8_t *)SIG2, sizeof(SIG2) };
    const ptarm_buf_t *sigs[] = { &sig1, &sig2 };
    const uint8_t REDEEM[] = {
        0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64,
        0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50,
        0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22,
        0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a,
        0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b, 0x52,
        0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf, 0x06,
        0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07, 0x3c,
        0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3, 0x37,
        0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03, 0x29,
        0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef, 0x97,
        0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2, 0x8c,
        0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a, 0x88,
        0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc, 0x53,
        0xae,
    };
    const ptarm_buf_t redeem = { (uint8_t *)REDEEM, sizeof(REDEEM) };
    const uint8_t SCRIPTSIG[] = {
        0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xd1,
        0x8a, 0xc1, 0x9e, 0x45, 0x57, 0xe0, 0x25, 0xaa,
        0x90, 0x0b, 0xc8, 0x01, 0x77, 0x98, 0x71, 0xb8,
        0x30, 0x98, 0x74, 0xc2, 0xe6, 0x2c, 0x9f, 0x84,
        0x7f, 0xb0, 0xe5, 0xfd, 0x6b, 0xbd, 0x8c, 0x02,
        0x20, 0x21, 0xe7, 0x40, 0x2c, 0x83, 0x3f, 0x95,
        0x49, 0x02, 0x3d, 0x11, 0x82, 0xa9, 0xae, 0x70,
        0x8b, 0x1a, 0x6d, 0xb5, 0xbc, 0x03, 0x83, 0xf0,
        0xb5, 0x52, 0x9d, 0xde, 0xaa, 0xec, 0x08, 0x3f,
        0x02, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00,
        0xe1, 0x1f, 0xd5, 0xcc, 0xf8, 0x8d, 0x90, 0x16,
        0x57, 0xb3, 0xce, 0x08, 0xbb, 0xa6, 0x3d, 0xdc,
        0x9a, 0x18, 0xd3, 0x02, 0xcc, 0xc3, 0x9c, 0xb1,
        0x2e, 0xca, 0xa0, 0x25, 0xaa, 0x2b, 0x82, 0x79,
        0x02, 0x20, 0x5d, 0x3a, 0xad, 0xc5, 0xd1, 0x04,
        0x7b, 0xe1, 0x48, 0x44, 0x04, 0xf3, 0x49, 0x2b,
        0xcf, 0x8f, 0x63, 0x2c, 0x75, 0xcd, 0x14, 0x6a,
        0xe8, 0xd8, 0x3f, 0x0d, 0x99, 0x1e, 0x21, 0xc6,
        0x97, 0xd2, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x03,
        0x24, 0x0b, 0xc7, 0x9a, 0x64, 0x79, 0x85, 0x1a,
        0xbe, 0x77, 0x64, 0x65, 0x50, 0x0a, 0x9f, 0xf2,
        0xf8, 0x80, 0x94, 0x0b, 0x22, 0x7b, 0xfc, 0xbc,
        0xb6, 0xd4, 0x79, 0x88, 0x6a, 0x31, 0x8f, 0xa0,
        0x21, 0x03, 0x92, 0x1b, 0x52, 0x4e, 0x16, 0xb8,
        0x1c, 0x81, 0x3b, 0xaf, 0x06, 0x2a, 0x28, 0x44,
        0xff, 0x68, 0x42, 0x07, 0x3c, 0xc0, 0xec, 0x60,
        0x92, 0x31, 0xa0, 0xe3, 0x37, 0x00, 0xdd, 0x24,
        0xb5, 0xf3, 0x21, 0x03, 0x29, 0xbd, 0x4a, 0x08,
        0x25, 0x0b, 0x6a, 0xef, 0x97, 0x58, 0x1b, 0x36,
        0x41, 0x2c, 0x9b, 0xe2, 0x8c, 0x84, 0xba, 0xb7,
        0x7d, 0x7a, 0x51, 0x8a, 0x88, 0x00, 0x3a, 0x18,
        0x0a, 0xfc, 0xfc, 0xdc, 0x53, 0xae,
    };

    bool ret = ptarm_tx_set_vin_p2sh(&tx, 0, sigs, 2, &redeem);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(SCRIPTSIG, tx.vin[0].script.buf, sizeof(SCRIPTSIG)));
    ASSERT_EQ(sizeof(SCRIPTSIG), tx.vin[0].script.len);

    ptarm_tx_free(&tx);
}


TEST_F(tx, create_p2pkh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //トランザクション:2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30

    //version1の例
    tx.version = 1;

    //vin
    const uint8_t TXID[] = {
        0xe5, 0xbf, 0x81, 0x02, 0x0b, 0x6d, 0xb2, 0xb4,
        0xd3, 0x56, 0xc4, 0xa6, 0xf8, 0xb2, 0xa7, 0xb0,
        0x4b, 0xf9, 0x0e, 0xfd, 0x2a, 0xc3, 0x0c, 0x6e,
        0x35, 0xcb, 0xd0, 0x0a, 0x51, 0x6b, 0xe4, 0x4c,
    };
    ptarm_tx_add_vin(&tx, TXID, 1);
    const uint8_t SIG[] = {
        0x30, 0x44, 0x02, 0x20, 0x04, 0x7c, 0x1b, 0x11,
        0x11, 0xbb, 0xe0, 0xfc, 0x09, 0xcf, 0x2e, 0xd2,
        0x8d, 0xd1, 0xab, 0xd6, 0x13, 0xc0, 0x2b, 0x74,
        0x7a, 0xf8, 0xed, 0xd1, 0x27, 0x48, 0x86, 0x65,
        0x42, 0x59, 0xbb, 0xfb, 0x02, 0x20, 0x1d, 0x00,
        0xca, 0x3f, 0xc1, 0x0a, 0x11, 0x1a, 0x5a, 0x3e,
        0xa0, 0x66, 0x99, 0x92, 0xe4, 0xad, 0x9a, 0x2f,
        0x1c, 0x40, 0x2e, 0xc5, 0xfd, 0x29, 0xd9, 0xe1,
        0x34, 0x8a, 0xb0, 0x58, 0x4f, 0xa2, 0x01,
    };
    const ptarm_buf_t sig = { (uint8_t *)SIG, sizeof(SIG) };
    const uint8_t PUB[] = {
        0x03, 0xbe, 0xce, 0xc4, 0x1f, 0x68, 0xd7, 0x7f,
        0xde, 0x9e, 0x97, 0x2c, 0x79, 0xaa, 0x0e, 0x6e,
        0x4e, 0x81, 0x8b, 0xd3, 0x04, 0x62, 0x76, 0x96,
        0x9e, 0x79, 0x37, 0x4e, 0xc0, 0x56, 0x1b, 0xa4,
        0x59,
    };
    bool ret = ptarm_tx_set_vin_p2pkh(&tx, 0, &sig, PUB);
    ASSERT_TRUE(ret);

    //vout
    ret = ptarm_tx_add_vout_p2pkh_addr(&tx, PTARM_BTC2SATOSHI(0.001), "mr8wpGyZErik2DezKZtvTCFrYb6t6L69pc");
    ret = ptarm_tx_add_vout_p2pkh_addr(&tx, PTARM_BTC2SATOSHI(0.492), "mwJyBWTEUYMdJ12JWwK3eXff48pxQU6685");

    //tx
    const uint8_t TX[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0xe5, 0xbf, 0x81,
        0x02, 0x0b, 0x6d, 0xb2, 0xb4, 0xd3, 0x56, 0xc4,
        0xa6, 0xf8, 0xb2, 0xa7, 0xb0, 0x4b, 0xf9, 0x0e,
        0xfd, 0x2a, 0xc3, 0x0c, 0x6e, 0x35, 0xcb, 0xd0,
        0x0a, 0x51, 0x6b, 0xe4, 0x4c, 0x01, 0x00, 0x00,
        0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x04,
        0x7c, 0x1b, 0x11, 0x11, 0xbb, 0xe0, 0xfc, 0x09,
        0xcf, 0x2e, 0xd2, 0x8d, 0xd1, 0xab, 0xd6, 0x13,
        0xc0, 0x2b, 0x74, 0x7a, 0xf8, 0xed, 0xd1, 0x27,
        0x48, 0x86, 0x65, 0x42, 0x59, 0xbb, 0xfb, 0x02,
        0x20, 0x1d, 0x00, 0xca, 0x3f, 0xc1, 0x0a, 0x11,
        0x1a, 0x5a, 0x3e, 0xa0, 0x66, 0x99, 0x92, 0xe4,
        0xad, 0x9a, 0x2f, 0x1c, 0x40, 0x2e, 0xc5, 0xfd,
        0x29, 0xd9, 0xe1, 0x34, 0x8a, 0xb0, 0x58, 0x4f,
        0xa2, 0x01, 0x21, 0x03, 0xbe, 0xce, 0xc4, 0x1f,
        0x68, 0xd7, 0x7f, 0xde, 0x9e, 0x97, 0x2c, 0x79,
        0xaa, 0x0e, 0x6e, 0x4e, 0x81, 0x8b, 0xd3, 0x04,
        0x62, 0x76, 0x96, 0x9e, 0x79, 0x37, 0x4e, 0xc0,
        0x56, 0x1b, 0xa4, 0x59, 0xff, 0xff, 0xff, 0xff,
        0x02, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x19, 0x76, 0xa9, 0x14, 0x74, 0x7f, 0xd5,
        0x2a, 0x1f, 0x44, 0xdb, 0xe6, 0x73, 0xf4, 0x2a,
        0x4f, 0x29, 0xd2, 0xae, 0x9c, 0x8f, 0x92, 0xc5,
        0x1c, 0x88, 0xac, 0x80, 0xbb, 0xee, 0x02, 0x00,
        0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xad,
        0x3d, 0xc2, 0xf5, 0x22, 0x96, 0xf9, 0x3c, 0x78,
        0x98, 0xeb, 0x63, 0x8b, 0x0d, 0x74, 0xf2, 0x7d,
        0x79, 0xef, 0xc3, 0x88, 0xac, 0x00, 0x00, 0x00,
        0x00,
    };
    ptarm_buf_t txbuf = PTARM_BUF_INIT;
    ret = ptarm_tx_create(&txbuf, &tx);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(TX, txbuf.buf, sizeof(TX)));
    ASSERT_EQ(sizeof(TX), txbuf.len);

    //txid
    //  2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    const uint8_t NEW_TXID[] = {
        0x30, 0xfa, 0xe6, 0xf6, 0xc7, 0x17, 0xa6, 0x91,
        0xa7, 0x6b, 0x3d, 0x8d, 0xa0, 0x54, 0x64, 0xe5,
        0x73, 0xc9, 0x3d, 0x28, 0x62, 0xa1, 0x4b, 0x61,
        0x8a, 0xa7, 0xe0, 0x03, 0x2b, 0x87, 0xbe, 0x2e,
    };
    uint8_t txid[PTARM_SZ_TXID];
    ret = ptarm_tx_txid_raw(txid, &txbuf);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(NEW_TXID, txid, sizeof(NEW_TXID)));
    ptarm_buf_free(&txbuf);

    //versionを変えると不一致になる
    tx.version = 2;
    ret = ptarm_tx_create(&txbuf, &tx);
    ASSERT_TRUE(ret);
    ASSERT_NE(0, memcmp(TX, txbuf.buf, sizeof(TX)));
    ASSERT_EQ(2, txbuf.buf[0]);     //バージョンは先頭
    ptarm_buf_free(&txbuf);

    ptarm_tx_free(&tx);
}


TEST_F(tx, read_p2pkh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //トランザクション:2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    //tx
    const uint8_t TX[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0xe5, 0xbf, 0x81,
        0x02, 0x0b, 0x6d, 0xb2, 0xb4, 0xd3, 0x56, 0xc4,
        0xa6, 0xf8, 0xb2, 0xa7, 0xb0, 0x4b, 0xf9, 0x0e,
        0xfd, 0x2a, 0xc3, 0x0c, 0x6e, 0x35, 0xcb, 0xd0,
        0x0a, 0x51, 0x6b, 0xe4, 0x4c, 0x01, 0x00, 0x00,
        0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x04,
        0x7c, 0x1b, 0x11, 0x11, 0xbb, 0xe0, 0xfc, 0x09,
        0xcf, 0x2e, 0xd2, 0x8d, 0xd1, 0xab, 0xd6, 0x13,
        0xc0, 0x2b, 0x74, 0x7a, 0xf8, 0xed, 0xd1, 0x27,
        0x48, 0x86, 0x65, 0x42, 0x59, 0xbb, 0xfb, 0x02,
        0x20, 0x1d, 0x00, 0xca, 0x3f, 0xc1, 0x0a, 0x11,
        0x1a, 0x5a, 0x3e, 0xa0, 0x66, 0x99, 0x92, 0xe4,
        0xad, 0x9a, 0x2f, 0x1c, 0x40, 0x2e, 0xc5, 0xfd,
        0x29, 0xd9, 0xe1, 0x34, 0x8a, 0xb0, 0x58, 0x4f,
        0xa2, 0x01, 0x21, 0x03, 0xbe, 0xce, 0xc4, 0x1f,
        0x68, 0xd7, 0x7f, 0xde, 0x9e, 0x97, 0x2c, 0x79,
        0xaa, 0x0e, 0x6e, 0x4e, 0x81, 0x8b, 0xd3, 0x04,
        0x62, 0x76, 0x96, 0x9e, 0x79, 0x37, 0x4e, 0xc0,
        0x56, 0x1b, 0xa4, 0x59, 0xff, 0xff, 0xff, 0xff,
        0x02, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x19, 0x76, 0xa9, 0x14, 0x74, 0x7f, 0xd5,
        0x2a, 0x1f, 0x44, 0xdb, 0xe6, 0x73, 0xf4, 0x2a,
        0x4f, 0x29, 0xd2, 0xae, 0x9c, 0x8f, 0x92, 0xc5,
        0x1c, 0x88, 0xac, 0x80, 0xbb, 0xee, 0x02, 0x00,
        0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xad,
        0x3d, 0xc2, 0xf5, 0x22, 0x96, 0xf9, 0x3c, 0x78,
        0x98, 0xeb, 0x63, 0x8b, 0x0d, 0x74, 0xf2, 0x7d,
        0x79, 0xef, 0xc3, 0x88, 0xac, 0x00, 0x00, 0x00,
        0x00,
    };

    bool ret = ptarm_tx_read(&tx, TX, sizeof(TX));
    ASSERT_TRUE(ret);

    ASSERT_EQ(1, tx.version);
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_TRUE(NULL != tx.vin);
    ASSERT_EQ(2, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout);
    ASSERT_EQ(0, tx.locktime);

    //vin
    const uint8_t TXID[] = {
        0xe5, 0xbf, 0x81, 0x02, 0x0b, 0x6d, 0xb2, 0xb4,
        0xd3, 0x56, 0xc4, 0xa6, 0xf8, 0xb2, 0xa7, 0xb0,
        0x4b, 0xf9, 0x0e, 0xfd, 0x2a, 0xc3, 0x0c, 0x6e,
        0x35, 0xcb, 0xd0, 0x0a, 0x51, 0x6b, 0xe4, 0x4c,
    };
    const uint8_t SCRIPTSIG[] = {
        0x47, 0x30, 0x44, 0x02, 0x20, 0x04, 0x7c, 0x1b,
        0x11, 0x11, 0xbb, 0xe0, 0xfc, 0x09, 0xcf, 0x2e,
        0xd2, 0x8d, 0xd1, 0xab, 0xd6, 0x13, 0xc0, 0x2b,
        0x74, 0x7a, 0xf8, 0xed, 0xd1, 0x27, 0x48, 0x86,
        0x65, 0x42, 0x59, 0xbb, 0xfb, 0x02, 0x20, 0x1d,
        0x00, 0xca, 0x3f, 0xc1, 0x0a, 0x11, 0x1a, 0x5a,
        0x3e, 0xa0, 0x66, 0x99, 0x92, 0xe4, 0xad, 0x9a,
        0x2f, 0x1c, 0x40, 0x2e, 0xc5, 0xfd, 0x29, 0xd9,
        0xe1, 0x34, 0x8a, 0xb0, 0x58, 0x4f, 0xa2, 0x01,
        0x21, 0x03, 0xbe, 0xce, 0xc4, 0x1f, 0x68, 0xd7,
        0x7f, 0xde, 0x9e, 0x97, 0x2c, 0x79, 0xaa, 0x0e,
        0x6e, 0x4e, 0x81, 0x8b, 0xd3, 0x04, 0x62, 0x76,
        0x96, 0x9e, 0x79, 0x37, 0x4e, 0xc0, 0x56, 0x1b,
        0xa4, 0x59,
    };
    const ptarm_vin_t *vin = &tx.vin[0];
    ASSERT_EQ(0, memcmp(TXID, vin->txid, PTARM_SZ_TXID));
    ASSERT_EQ(1, vin->index);
    ASSERT_EQ(0, memcmp(SCRIPTSIG, vin->script.buf, sizeof(SCRIPTSIG)));
    ASSERT_EQ(sizeof(SCRIPTSIG), vin->script.len);
    ASSERT_EQ(0, vin->wit_cnt);
    ASSERT_TRUE(NULL == vin->witness);
    ASSERT_EQ(0xffffffff, vin->sequence);

    //vout
    const uint8_t SCRIPTPK0[] = {
        0x76, 0xa9, 0x14, 0x74, 0x7f, 0xd5, 0x2a, 0x1f,
        0x44, 0xdb, 0xe6, 0x73, 0xf4, 0x2a, 0x4f, 0x29,
        0xd2, 0xae, 0x9c, 0x8f, 0x92, 0xc5, 0x1c, 0x88,
        0xac,
    };
    const uint8_t SCRIPTPK1[] = {
        0x76, 0xa9, 0x14, 0xad, 0x3d, 0xc2, 0xf5, 0x22,
        0x96, 0xf9, 0x3c, 0x78, 0x98, 0xeb, 0x63, 0x8b,
        0x0d, 0x74, 0xf2, 0x7d, 0x79, 0xef, 0xc3, 0x88,
        0xac,
    };
    const ptarm_vout_t *vout = &tx.vout[0];
    ASSERT_EQ(PTARM_BTC2SATOSHI(0.001), vout->value);
    ASSERT_EQ(0, memcmp(SCRIPTPK0, vout->script.buf, sizeof(SCRIPTPK0)));
    ASSERT_EQ(sizeof(SCRIPTPK0), vout->script.len);
    vout = &tx.vout[1];
    ASSERT_EQ(PTARM_BTC2SATOSHI(0.492), vout->value);
    ASSERT_EQ(0, memcmp(SCRIPTPK1, vout->script.buf, sizeof(SCRIPTPK1)));
    ASSERT_EQ(sizeof(SCRIPTPK1), vout->script.len);

    //txid
    //  2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    const uint8_t NEW_TXID[] = {
        0x30, 0xfa, 0xe6, 0xf6, 0xc7, 0x17, 0xa6, 0x91,
        0xa7, 0x6b, 0x3d, 0x8d, 0xa0, 0x54, 0x64, 0xe5,
        0x73, 0xc9, 0x3d, 0x28, 0x62, 0xa1, 0x4b, 0x61,
        0x8a, 0xa7, 0xe0, 0x03, 0x2b, 0x87, 0xbe, 0x2e,
    };
    uint8_t txid[PTARM_SZ_TXID];
    ret = ptarm_tx_txid(txid, &tx);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(NEW_TXID, txid, sizeof(NEW_TXID)));

    ptarm_tx_free(&tx);
}


TEST_F(tx, create_p2sh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //トランザクション:7359a2e1c945d1daf8ead20f51f74508ce8b463261643931b17b8099d0f2090c

    //version1の例
    tx.version = 1;

    //vin
    const uint8_t TXID[] = {
        0x33, 0x69, 0xbf, 0xb4, 0xb5, 0x62, 0xe9, 0x10,
        0xb0, 0xee, 0xb9, 0x6e, 0x8f, 0x1d, 0x0f, 0xfb,
        0x97, 0xec, 0x2d, 0xe4, 0x8a, 0x3c, 0x1e, 0x41,
        0x51, 0xac, 0xa6, 0xda, 0xf0, 0x6c, 0x84, 0x89,
    };
    ptarm_tx_add_vin(&tx, TXID, 0);
    const uint8_t SIG1[] = {
        0x30, 0x45, 0x02, 0x21, 0x00, 0xd1, 0x8a, 0xc1,
        0x9e, 0x45, 0x57, 0xe0, 0x25, 0xaa, 0x90, 0x0b,
        0xc8, 0x01, 0x77, 0x98, 0x71, 0xb8, 0x30, 0x98,
        0x74, 0xc2, 0xe6, 0x2c, 0x9f, 0x84, 0x7f, 0xb0,
        0xe5, 0xfd, 0x6b, 0xbd, 0x8c, 0x02, 0x20, 0x21,
        0xe7, 0x40, 0x2c, 0x83, 0x3f, 0x95, 0x49, 0x02,
        0x3d, 0x11, 0x82, 0xa9, 0xae, 0x70, 0x8b, 0x1a,
        0x6d, 0xb5, 0xbc, 0x03, 0x83, 0xf0, 0xb5, 0x52,
        0x9d, 0xde, 0xaa, 0xec, 0x08, 0x3f, 0x02, 0x01,
    };
    const ptarm_buf_t sig1 = { (uint8_t *)SIG1, sizeof(SIG1) };
    const uint8_t SIG2[] = {
        0x30, 0x45, 0x02, 0x21, 0x00, 0xe1, 0x1f, 0xd5,
        0xcc, 0xf8, 0x8d, 0x90, 0x16, 0x57, 0xb3, 0xce,
        0x08, 0xbb, 0xa6, 0x3d, 0xdc, 0x9a, 0x18, 0xd3,
        0x02, 0xcc, 0xc3, 0x9c, 0xb1, 0x2e, 0xca, 0xa0,
        0x25, 0xaa, 0x2b, 0x82, 0x79, 0x02, 0x20, 0x5d,
        0x3a, 0xad, 0xc5, 0xd1, 0x04, 0x7b, 0xe1, 0x48,
        0x44, 0x04, 0xf3, 0x49, 0x2b, 0xcf, 0x8f, 0x63,
        0x2c, 0x75, 0xcd, 0x14, 0x6a, 0xe8, 0xd8, 0x3f,
        0x0d, 0x99, 0x1e, 0x21, 0xc6, 0x97, 0xd2, 0x01,
    };
    const ptarm_buf_t sig2 = { (uint8_t *)SIG2, sizeof(SIG2) };
    const ptarm_buf_t *sigs[] = { &sig1, &sig2 };
    const uint8_t REDEEM[] = {
        0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64,
        0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50,
        0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22,
        0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a,
        0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b, 0x52,
        0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf, 0x06,
        0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07, 0x3c,
        0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3, 0x37,
        0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03, 0x29,
        0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef, 0x97,
        0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2, 0x8c,
        0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a, 0x88,
        0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc, 0x53,
        0xae,
    };
    const ptarm_buf_t redeem = { (uint8_t *)REDEEM, sizeof(REDEEM) };
    bool ret = ptarm_tx_set_vin_p2sh(&tx, 0, sigs, 2, &redeem);
    ASSERT_TRUE(ret);

    //vout
    ret = ptarm_tx_add_vout_p2pkh_addr(&tx, PTARM_BTC2SATOSHI(0.007), "n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi");
    ASSERT_TRUE(ret);

    //tx
    const uint8_t TX[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x33, 0x69, 0xbf,
        0xb4, 0xb5, 0x62, 0xe9, 0x10, 0xb0, 0xee, 0xb9,
        0x6e, 0x8f, 0x1d, 0x0f, 0xfb, 0x97, 0xec, 0x2d,
        0xe4, 0x8a, 0x3c, 0x1e, 0x41, 0x51, 0xac, 0xa6,
        0xda, 0xf0, 0x6c, 0x84, 0x89, 0x00, 0x00, 0x00,
        0x00, 0xFD, 0xFE, 0x00, 0x00, 0x48, 0x30, 0x45,
        0x02, 0x21, 0x00, 0xd1, 0x8a, 0xc1, 0x9e, 0x45,
        0x57, 0xe0, 0x25, 0xaa, 0x90, 0x0b, 0xc8, 0x01,
        0x77, 0x98, 0x71, 0xb8, 0x30, 0x98, 0x74, 0xc2,
        0xe6, 0x2c, 0x9f, 0x84, 0x7f, 0xb0, 0xe5, 0xfd,
        0x6b, 0xbd, 0x8c, 0x02, 0x20, 0x21, 0xe7, 0x40,
        0x2c, 0x83, 0x3f, 0x95, 0x49, 0x02, 0x3d, 0x11,
        0x82, 0xa9, 0xae, 0x70, 0x8b, 0x1a, 0x6d, 0xb5,
        0xbc, 0x03, 0x83, 0xf0, 0xb5, 0x52, 0x9d, 0xde,
        0xaa, 0xec, 0x08, 0x3f, 0x02, 0x01, 0x48, 0x30,
        0x45, 0x02, 0x21, 0x00, 0xe1, 0x1f, 0xd5, 0xcc,
        0xf8, 0x8d, 0x90, 0x16, 0x57, 0xb3, 0xce, 0x08,
        0xbb, 0xa6, 0x3d, 0xdc, 0x9a, 0x18, 0xd3, 0x02,
        0xcc, 0xc3, 0x9c, 0xb1, 0x2e, 0xca, 0xa0, 0x25,
        0xaa, 0x2b, 0x82, 0x79, 0x02, 0x20, 0x5d, 0x3a,
        0xad, 0xc5, 0xd1, 0x04, 0x7b, 0xe1, 0x48, 0x44,
        0x04, 0xf3, 0x49, 0x2b, 0xcf, 0x8f, 0x63, 0x2c,
        0x75, 0xcd, 0x14, 0x6a, 0xe8, 0xd8, 0x3f, 0x0d,
        0x99, 0x1e, 0x21, 0xc6, 0x97, 0xd2, 0x01, 0x4c,
        0x69, 0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a,
        0x64, 0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65,
        0x50, 0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b,
        0x22, 0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88,
        0x6a, 0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b,
        0x52, 0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf,
        0x06, 0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07,
        0x3c, 0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3,
        0x37, 0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03,
        0x29, 0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef,
        0x97, 0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2,
        0x8c, 0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a,
        0x88, 0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc,
        0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x01, 0x60,
        0xae, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19,
        0x76, 0xa9, 0x14, 0xe7, 0xc1, 0x34, 0x5f, 0xc8,
        0xf8, 0x7c, 0x68, 0x17, 0x0b, 0x3a, 0xa7, 0x98,
        0xa9, 0x56, 0xc2, 0xfe, 0x6a, 0x9e, 0xff, 0x88,
        0xac, 0x00, 0x00, 0x00, 0x00,
    };
    ptarm_buf_t txbuf = PTARM_BUF_INIT;
    ret = ptarm_tx_create(&txbuf, &tx);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(TX, txbuf.buf, sizeof(TX)));
    ASSERT_EQ(sizeof(TX), txbuf.len);

    //txid
    //  7359a2e1c945d1daf8ead20f51f74508ce8b463261643931b17b8099d0f2090c
    const uint8_t NEW_TXID[] = {
        0x0c, 0x09, 0xf2, 0xd0, 0x99, 0x80, 0x7b, 0xb1,
        0x31, 0x39, 0x64, 0x61, 0x32, 0x46, 0x8b, 0xce,
        0x08, 0x45, 0xf7, 0x51, 0x0f, 0xd2, 0xea, 0xf8,
        0xda, 0xd1, 0x45, 0xc9, 0xe1, 0xa2, 0x59, 0x73,
    };
    uint8_t txid[PTARM_SZ_TXID];
    ret = ptarm_tx_txid_raw(txid, &txbuf);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(NEW_TXID, txid, sizeof(NEW_TXID)));
    ptarm_buf_free(&txbuf);

    //versionを変えると不一致になる
    tx.version = 2;
    ret = ptarm_tx_create(&txbuf, &tx);
    ASSERT_TRUE(ret);
    ASSERT_NE(0, memcmp(TX, txbuf.buf, sizeof(TX)));
    ASSERT_EQ(2, txbuf.buf[0]);     //バージョンは先頭
    ptarm_buf_free(&txbuf);

    ptarm_tx_free(&tx);
}


TEST_F(tx, read_p2sh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //トランザクション:7359a2e1c945d1daf8ead20f51f74508ce8b463261643931b17b8099d0f2090c
    //tx
    const uint8_t TX[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x33, 0x69, 0xbf,
        0xb4, 0xb5, 0x62, 0xe9, 0x10, 0xb0, 0xee, 0xb9,
        0x6e, 0x8f, 0x1d, 0x0f, 0xfb, 0x97, 0xec, 0x2d,
        0xe4, 0x8a, 0x3c, 0x1e, 0x41, 0x51, 0xac, 0xa6,
        0xda, 0xf0, 0x6c, 0x84, 0x89, 0x00, 0x00, 0x00,
        0x00, 0xFD, 0xFE, 0x00, 0x00, 0x48, 0x30, 0x45,
        0x02, 0x21, 0x00, 0xd1, 0x8a, 0xc1, 0x9e, 0x45,
        0x57, 0xe0, 0x25, 0xaa, 0x90, 0x0b, 0xc8, 0x01,
        0x77, 0x98, 0x71, 0xb8, 0x30, 0x98, 0x74, 0xc2,
        0xe6, 0x2c, 0x9f, 0x84, 0x7f, 0xb0, 0xe5, 0xfd,
        0x6b, 0xbd, 0x8c, 0x02, 0x20, 0x21, 0xe7, 0x40,
        0x2c, 0x83, 0x3f, 0x95, 0x49, 0x02, 0x3d, 0x11,
        0x82, 0xa9, 0xae, 0x70, 0x8b, 0x1a, 0x6d, 0xb5,
        0xbc, 0x03, 0x83, 0xf0, 0xb5, 0x52, 0x9d, 0xde,
        0xaa, 0xec, 0x08, 0x3f, 0x02, 0x01, 0x48, 0x30,
        0x45, 0x02, 0x21, 0x00, 0xe1, 0x1f, 0xd5, 0xcc,
        0xf8, 0x8d, 0x90, 0x16, 0x57, 0xb3, 0xce, 0x08,
        0xbb, 0xa6, 0x3d, 0xdc, 0x9a, 0x18, 0xd3, 0x02,
        0xcc, 0xc3, 0x9c, 0xb1, 0x2e, 0xca, 0xa0, 0x25,
        0xaa, 0x2b, 0x82, 0x79, 0x02, 0x20, 0x5d, 0x3a,
        0xad, 0xc5, 0xd1, 0x04, 0x7b, 0xe1, 0x48, 0x44,
        0x04, 0xf3, 0x49, 0x2b, 0xcf, 0x8f, 0x63, 0x2c,
        0x75, 0xcd, 0x14, 0x6a, 0xe8, 0xd8, 0x3f, 0x0d,
        0x99, 0x1e, 0x21, 0xc6, 0x97, 0xd2, 0x01, 0x4c,
        0x69, 0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a,
        0x64, 0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65,
        0x50, 0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b,
        0x22, 0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88,
        0x6a, 0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b,
        0x52, 0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf,
        0x06, 0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07,
        0x3c, 0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3,
        0x37, 0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03,
        0x29, 0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef,
        0x97, 0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2,
        0x8c, 0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a,
        0x88, 0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc,
        0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x01, 0x60,
        0xae, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19,
        0x76, 0xa9, 0x14, 0xe7, 0xc1, 0x34, 0x5f, 0xc8,
        0xf8, 0x7c, 0x68, 0x17, 0x0b, 0x3a, 0xa7, 0x98,
        0xa9, 0x56, 0xc2, 0xfe, 0x6a, 0x9e, 0xff, 0x88,
        0xac, 0x00, 0x00, 0x00, 0x00,
    };

    bool ret = ptarm_tx_read(&tx, TX, sizeof(TX));
    ASSERT_TRUE(ret);

    ASSERT_EQ(1, tx.version);
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_TRUE(NULL != tx.vin);
    ASSERT_EQ(1, tx.vout_cnt);
    ASSERT_TRUE(NULL != tx.vout);
    ASSERT_EQ(0, tx.locktime);

    //vin
    const uint8_t TXID[] = {
        0x33, 0x69, 0xbf, 0xb4, 0xb5, 0x62, 0xe9, 0x10,
        0xb0, 0xee, 0xb9, 0x6e, 0x8f, 0x1d, 0x0f, 0xfb,
        0x97, 0xec, 0x2d, 0xe4, 0x8a, 0x3c, 0x1e, 0x41,
        0x51, 0xac, 0xa6, 0xda, 0xf0, 0x6c, 0x84, 0x89,
    };
    const uint8_t SCRIPTSIG[] = {
        0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xd1,
        0x8a, 0xc1, 0x9e, 0x45, 0x57, 0xe0, 0x25, 0xaa,
        0x90, 0x0b, 0xc8, 0x01, 0x77, 0x98, 0x71, 0xb8,
        0x30, 0x98, 0x74, 0xc2, 0xe6, 0x2c, 0x9f, 0x84,
        0x7f, 0xb0, 0xe5, 0xfd, 0x6b, 0xbd, 0x8c, 0x02,
        0x20, 0x21, 0xe7, 0x40, 0x2c, 0x83, 0x3f, 0x95,
        0x49, 0x02, 0x3d, 0x11, 0x82, 0xa9, 0xae, 0x70,
        0x8b, 0x1a, 0x6d, 0xb5, 0xbc, 0x03, 0x83, 0xf0,
        0xb5, 0x52, 0x9d, 0xde, 0xaa, 0xec, 0x08, 0x3f,
        0x02, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00,
        0xe1, 0x1f, 0xd5, 0xcc, 0xf8, 0x8d, 0x90, 0x16,
        0x57, 0xb3, 0xce, 0x08, 0xbb, 0xa6, 0x3d, 0xdc,
        0x9a, 0x18, 0xd3, 0x02, 0xcc, 0xc3, 0x9c, 0xb1,
        0x2e, 0xca, 0xa0, 0x25, 0xaa, 0x2b, 0x82, 0x79,
        0x02, 0x20, 0x5d, 0x3a, 0xad, 0xc5, 0xd1, 0x04,
        0x7b, 0xe1, 0x48, 0x44, 0x04, 0xf3, 0x49, 0x2b,
        0xcf, 0x8f, 0x63, 0x2c, 0x75, 0xcd, 0x14, 0x6a,
        0xe8, 0xd8, 0x3f, 0x0d, 0x99, 0x1e, 0x21, 0xc6,
        0x97, 0xd2, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x03,
        0x24, 0x0b, 0xc7, 0x9a, 0x64, 0x79, 0x85, 0x1a,
        0xbe, 0x77, 0x64, 0x65, 0x50, 0x0a, 0x9f, 0xf2,
        0xf8, 0x80, 0x94, 0x0b, 0x22, 0x7b, 0xfc, 0xbc,
        0xb6, 0xd4, 0x79, 0x88, 0x6a, 0x31, 0x8f, 0xa0,
        0x21, 0x03, 0x92, 0x1b, 0x52, 0x4e, 0x16, 0xb8,
        0x1c, 0x81, 0x3b, 0xaf, 0x06, 0x2a, 0x28, 0x44,
        0xff, 0x68, 0x42, 0x07, 0x3c, 0xc0, 0xec, 0x60,
        0x92, 0x31, 0xa0, 0xe3, 0x37, 0x00, 0xdd, 0x24,
        0xb5, 0xf3, 0x21, 0x03, 0x29, 0xbd, 0x4a, 0x08,
        0x25, 0x0b, 0x6a, 0xef, 0x97, 0x58, 0x1b, 0x36,
        0x41, 0x2c, 0x9b, 0xe2, 0x8c, 0x84, 0xba, 0xb7,
        0x7d, 0x7a, 0x51, 0x8a, 0x88, 0x00, 0x3a, 0x18,
        0x0a, 0xfc, 0xfc, 0xdc, 0x53, 0xae,
    };
    const ptarm_vin_t *vin = &tx.vin[0];
    ASSERT_EQ(0, memcmp(TXID, vin->txid, PTARM_SZ_TXID));
    ASSERT_EQ(0, vin->index);
    ASSERT_EQ(0, memcmp(SCRIPTSIG, vin->script.buf, sizeof(SCRIPTSIG)));
    ASSERT_EQ(sizeof(SCRIPTSIG), vin->script.len);
    ASSERT_EQ(0, vin->wit_cnt);
    ASSERT_TRUE(NULL == vin->witness);
    ASSERT_EQ(0xffffffff, vin->sequence);

    //vout
    const uint8_t SCRIPTPK0[] = {
        0x76, 0xa9, 0x14, 0xe7, 0xc1, 0x34, 0x5f, 0xc8,
        0xf8, 0x7c, 0x68, 0x17, 0x0b, 0x3a, 0xa7, 0x98,
        0xa9, 0x56, 0xc2, 0xfe, 0x6a, 0x9e, 0xff, 0x88,
        0xac,
    };
    const ptarm_vout_t *vout = &tx.vout[0];
    ASSERT_EQ(PTARM_BTC2SATOSHI(0.007), vout->value);
    ASSERT_EQ(0, memcmp(SCRIPTPK0, vout->script.buf, sizeof(SCRIPTPK0)));
    ASSERT_EQ(sizeof(SCRIPTPK0), vout->script.len);

    //txid
    //  7359a2e1c945d1daf8ead20f51f74508ce8b463261643931b17b8099d0f2090c
    const uint8_t NEW_TXID[] = {
        0x0c, 0x09, 0xf2, 0xd0, 0x99, 0x80, 0x7b, 0xb1,
        0x31, 0x39, 0x64, 0x61, 0x32, 0x46, 0x8b, 0xce,
        0x08, 0x45, 0xf7, 0x51, 0x0f, 0xd2, 0xea, 0xf8,
        0xda, 0xd1, 0x45, 0xc9, 0xe1, 0xa2, 0x59, 0x73,
    };
    uint8_t txid[PTARM_SZ_TXID];
    ret = ptarm_tx_txid(txid, &tx);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(NEW_TXID, txid, sizeof(NEW_TXID)));

    ptarm_tx_free(&tx);
}


TEST_F(tx, sighash_p2pkh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //$ bitcoin-cli createrawtransaction '[{"txid" : "4ce46b510ad0cb356e0cc32afd0ef94bb0a7b2f8a6c456d3b4b26d0b0281bfe5", "vout" : 1}]' '{"mr8wpGyZErik2DezKZtvTCFrYb6t6L69pc" : 0.001, "mwJyBWTEUYMdJ12JWwK3eXff48pxQU6685" : 0.492}'
    const uint8_t TX_EMPTY[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0xe5, 0xbf, 0x81,
        0x02, 0x0b, 0x6d, 0xb2, 0xb4, 0xd3, 0x56, 0xc4,
        0xa6, 0xf8, 0xb2, 0xa7, 0xb0, 0x4b, 0xf9, 0x0e,
        0xfd, 0x2a, 0xc3, 0x0c, 0x6e, 0x35, 0xcb, 0xd0,
        0x0a, 0x51, 0x6b, 0xe4, 0x4c, 0x01, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0xa0,
        0x86, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19,
        0x76, 0xa9, 0x14, 0x74, 0x7f, 0xd5, 0x2a, 0x1f,
        0x44, 0xdb, 0xe6, 0x73, 0xf4, 0x2a, 0x4f, 0x29,
        0xd2, 0xae, 0x9c, 0x8f, 0x92, 0xc5, 0x1c, 0x88,
        0xac, 0x80, 0xbb, 0xee, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x19, 0x76, 0xa9, 0x14, 0xad, 0x3d, 0xc2,
        0xf5, 0x22, 0x96, 0xf9, 0x3c, 0x78, 0x98, 0xeb,
        0x63, 0x8b, 0x0d, 0x74, 0xf2, 0x7d, 0x79, 0xef,
        0xc3, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00,
    };

    bool ret = ptarm_tx_read(&tx, TX_EMPTY, sizeof(TX_EMPTY));
    ASSERT_TRUE(ret);

    const uint8_t PREV_SCRIPTPK[] = {
        0x76, 0xa9, 0x14, 0xad, 0x3d, 0xc2, 0xf5, 0x22,
        0x96, 0xf9, 0x3c, 0x78, 0x98, 0xeb, 0x63, 0x8b,
        0x0d, 0x74, 0xf2, 0x7d, 0x79, 0xef, 0xc3, 0x88,
        0xac,
    };
    const ptarm_buf_t pk0 = { (uint8_t *)PREV_SCRIPTPK, sizeof(PREV_SCRIPTPK) };
    const ptarm_buf_t *pks[] = { &pk0 };
    const uint8_t TXHASH[] = {
        0xb8, 0x81, 0xab, 0x3c, 0x47, 0x0b, 0x93, 0x98,
        0xad, 0xb5, 0xea, 0x6c, 0xb3, 0x60, 0xd1, 0x45,
        0xdf, 0x70, 0x2f, 0xa0, 0xbc, 0x0a, 0x6c, 0x01,
        0x22, 0x19, 0xfa, 0x93, 0xe7, 0x09, 0xad, 0xad,
    };
    uint8_t txhash[PTARM_SZ_HASH256];
    ret = ptarm_tx_sighash(txhash, &tx, pks, 1);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(TXHASH, txhash, PTARM_SZ_HASH256));
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_EQ(NULL, tx.vin[0].script.buf);
    ASSERT_EQ(0, tx.vin[0].script.len);

    //txid: 2ebe872b03e0a78a614ba162283dc973e56454a08d3d6ba791a617c7f6e6fa30
    //privkey: cd77aca001fe88e8f2dcdcc7fcd86c34d2af546682cfede65f9ed848a81dfac6
    //pubkey: 03becec41f68d77fde9e972c79aa0e6e4e818bd3046276969e79374ec0561ba459
    const uint8_t PRIV[] = {
        0xcd, 0x77, 0xac, 0xa0, 0x01, 0xfe, 0x88, 0xe8,
        0xf2, 0xdc, 0xdc, 0xc7, 0xfc, 0xd8, 0x6c, 0x34,
        0xd2, 0xaf, 0x54, 0x66, 0x82, 0xcf, 0xed, 0xe6,
        0x5f, 0x9e, 0xd8, 0x48, 0xa8, 0x1d, 0xfa, 0xc6,
    };
    ptarm_buf_t sig;
    ret = ptarm_tx_sign(&sig, txhash, PRIV);
    ASSERT_TRUE(ret);

    //送信可能なtxだが、使用済みTXIDなので送信確認はできない
    uint8_t pubkey[PTARM_SZ_PUBKEY];
    ptarm_keys_priv2pub(pubkey, PRIV);
    ret = ptarm_tx_set_vin_p2pkh(&tx, 0, &sig, pubkey);
    ASSERT_TRUE(ret);
    ptarm_buf_t txall;
    ptarm_tx_create(&txall, &tx);
//    printf("P2PKH tx=\n");
//    tx::DumpBin(txall.buf, txall.len);

    ret = ptarm_tx_sign_p2pkh(&tx, 0, txhash, PRIV, pubkey);
    ASSERT_TRUE(ret);
    ptarm_buf_t txall2;
    ptarm_tx_create(&txall2, &tx);
    ASSERT_EQ(0, memcmp(txall.buf, txall2.buf, txall.len));
    ASSERT_EQ(txall.len, txall2.len);
    ptarm_buf_free(&txall2);
    //pubkey==NULL
    ret = ptarm_tx_sign_p2pkh(&tx, 0, txhash, PRIV, NULL);
    ASSERT_TRUE(ret);
    ptarm_tx_create(&txall2, &tx);
    ASSERT_EQ(0, memcmp(txall.buf, txall2.buf, txall.len));
    ASSERT_EQ(txall.len, txall2.len);
    ptarm_buf_free(&txall2);

    //verify
    ret = ptarm_tx_verify(&sig, txhash, pubkey);
    ASSERT_TRUE(ret);
    sig.buf[sig.len - 1] = 0x00;
    ret = ptarm_tx_verify(&sig, txhash, pubkey);
    ASSERT_FALSE(ret);
    sig.buf[sig.len - 1] = 0x01;
    uint8_t bak = sig.buf[20];      //20は根拠無し
    sig.buf[20] = ~sig.buf[20];
    ret = ptarm_tx_verify(&sig, txhash, pubkey);
    ASSERT_FALSE(ret);
    sig.buf[20] = bak;

    //verify(readしたデータ)
    ptarm_tx_t tx_read;
    ptarm_tx_init(&tx_read);
    ptarm_tx_read(&tx_read, txall.buf, txall.len);
    ptarm_buf_free(&txall);
    ret = ptarm_tx_verify_p2pkh_spk(&tx_read, 0, txhash, &pk0);
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify_p2pkh_addr(&tx_read, 0, txhash, "mwJyBWTEUYMdJ12JWwK3eXff48pxQU6685");
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify_p2pkh_addr(&tx_read, 0, txhash, "mwJyBWTEUYMdJ22JWwK3eXff48pxQU6685");
    ASSERT_FALSE(ret);
    ptarm_tx_free(&tx_read);

    //他でチェックするための出力
    printf("pubkey= 03becec41f68d77fde9e972c79aa0e6e4e818bd3046276969e79374ec0561ba459");
    printf("txhash= ");
    tx::DumpBin(txhash, sizeof(txhash));
    printf("sigData= ");
    tx::DumpBin(sig.buf, sig.len);

    ptarm_buf_free(&sig);
    ptarm_tx_free(&tx);
}


TEST_F(tx, sighash_p2sh)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //2-of-3
    //$ bitcoin-cli createrawtransaction '[{"txid":"89846cf0daa6ac51411e3c8ae42dec97fb0f1d8f6eb9eeb010e962b5b4bf6933","vout":0}]' '{"n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi":0.007}'
    const uint8_t TX_EMPTY[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x33, 0x69, 0xbf,
        0xb4, 0xb5, 0x62, 0xe9, 0x10, 0xb0, 0xee, 0xb9,
        0x6e, 0x8f, 0x1d, 0x0f, 0xfb, 0x97, 0xec, 0x2d,
        0xe4, 0x8a, 0x3c, 0x1e, 0x41, 0x51, 0xac, 0xa6,
        0xda, 0xf0, 0x6c, 0x84, 0x89, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x01, 0x60,
        0xae, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19,
        0x76, 0xa9, 0x14, 0xe7, 0xc1, 0x34, 0x5f, 0xc8,
        0xf8, 0x7c, 0x68, 0x17, 0x0b, 0x3a, 0xa7, 0x98,
        0xa9, 0x56, 0xc2, 0xfe, 0x6a, 0x9e, 0xff, 0x88,
        0xac, 0x00, 0x00, 0x00, 0x00,
    };

    bool ret = ptarm_tx_read(&tx, TX_EMPTY, sizeof(TX_EMPTY));
    ASSERT_TRUE(ret);

    const uint8_t PREV_REDEEM[] = {
        0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64,
        0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50,
        0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22,
        0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a,
        0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b, 0x52,
        0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf, 0x06,
        0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07, 0x3c,
        0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3, 0x37,
        0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03, 0x29,
        0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef, 0x97,
        0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2, 0x8c,
        0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a, 0x88,
        0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc, 0x53,
        0xae,
    };
    const ptarm_buf_t redeem0 = { (uint8_t *)PREV_REDEEM, sizeof(PREV_REDEEM) };
    const ptarm_buf_t *pks[] = { &redeem0 };
    const uint8_t TXHASH[] = {
        0xc3, 0x00, 0x8f, 0x64, 0xac, 0x71, 0x05, 0x9c,
        0xd3, 0x1f, 0xaf, 0x84, 0x9c, 0x02, 0x3c, 0xc5,
        0xc9, 0xe7, 0x8d, 0x02, 0x88, 0x71, 0xc7, 0x31,
        0x84, 0x45, 0x0d, 0x0f, 0xd3, 0x3f, 0x63, 0x04,
    };
    uint8_t txhash[PTARM_SZ_HASH256];
    ret = ptarm_tx_sighash(txhash, &tx, pks, 1);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(TXHASH, txhash, PTARM_SZ_HASH256));
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_EQ(NULL, tx.vin[0].script.buf);
    ASSERT_EQ(0, tx.vin[0].script.len);

    //
    const uint8_t PRIV1[] = {
        0x8b, 0xa9, 0x75, 0x45, 0x9f, 0xe9, 0x10, 0x67,
        0xce, 0xec, 0x41, 0xfe, 0x99, 0xd7, 0xb4, 0x2b,
        0x6b, 0x36, 0x6a, 0x4a, 0x33, 0x40, 0xf4, 0x40,
        0x66, 0xa1, 0x21, 0x68, 0x6e, 0xfc, 0x04, 0xb7,
    };
    const uint8_t PUB1[] = {
        0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64, 0x79, 0x85,
        0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50, 0x0a, 0x9f,
        0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22, 0x7b, 0xfc,
        0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a, 0x31, 0x8f,
        0xa0,
    };
//    const uint8_t PRIV2[] = {
//        0x92, 0x14, 0xfb, 0xdb, 0xb1, 0x24, 0x67, 0x7c,
//        0xb7, 0xfa, 0x6a, 0x5d, 0x84, 0x4d, 0xb8, 0x49,
//        0xde, 0x8a, 0x43, 0x15, 0x1c, 0x89, 0x68, 0x72,
//        0xd2, 0x85, 0x60, 0x73, 0x51, 0x21, 0x52, 0xd8,
//    };
    const uint8_t PUB2[] = {
        0x03, 0x92, 0x1b, 0x52, 0x4e, 0x16, 0xb8, 0x1c,
        0x81, 0x3b, 0xaf, 0x06, 0x2a, 0x28, 0x44, 0xff,
        0x68, 0x42, 0x07, 0x3c, 0xc0, 0xec, 0x60, 0x92,
        0x31, 0xa0, 0xe3, 0x37, 0x00, 0xdd, 0x24, 0xb5,
        0xf3,
    };
    const uint8_t PRIV3[] = {
        0xff, 0x63, 0x1f, 0xe7, 0x56, 0xd7, 0xdc, 0x3f,
        0x1c, 0xff, 0x88, 0xcd, 0x12, 0xfa, 0xa7, 0x08,
        0x9d, 0x1f, 0x20, 0x45, 0x21, 0x98, 0xe7, 0x77,
        0x03, 0xce, 0xdb, 0x09, 0x3e, 0x94, 0x0d, 0x0c,
    };
    const uint8_t PUB3[] = {
        0x03, 0x29, 0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a,
        0xef, 0x97, 0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b,
        0xe2, 0x8c, 0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51,
        0x8a, 0x88, 0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc,
        0xdc,
    };
    ptarm_buf_t sig1;
    ptarm_buf_t sig2;
    ret = ptarm_tx_sign(&sig1, txhash, PRIV1);
    ASSERT_TRUE(ret);
    ret = ptarm_tx_sign(&sig2, txhash, PRIV3);
    ASSERT_TRUE(ret);

    //送信可能なtxだが、使用済みTXIDなので送信確認はできない
    const ptarm_buf_t *sigs[] = { &sig1, &sig2 };
    const ptarm_buf_t redeem = { (uint8_t *)PREV_REDEEM, sizeof(PREV_REDEEM) };
    ret = ptarm_tx_set_vin_p2sh(&tx, 0, sigs, 2, &redeem);
    ASSERT_TRUE(ret);
    ptarm_buf_t txall;
    ptarm_tx_create(&txall, &tx);
    printf("P2SH tx=\n");
    tx::DumpBin(txall.buf, txall.len);
    ptarm_buf_free(&txall);

//    printf("priv1= ");
//    tx::DumpBin(PRIV1, sizeof(PRIV1));
//    printf("pub1= ");
//    tx::DumpBin(PUB1, sizeof(PUB1));
//    printf("priv2= ");
//    tx::DumpBin(PRIV2, sizeof(PRIV2));
//    printf("pub2= ");
//    tx::DumpBin(PUB2, sizeof(PUB2));
//    printf("priv3= ");
//    tx::DumpBin(PRIV3, sizeof(PRIV3));
//    printf("pub3= ");
//    tx::DumpBin(PUB3, sizeof(PUB3));

    //verify
    ret = ptarm_tx_verify(&sig1, txhash, PUB1);
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify(&sig2, txhash, PUB2);
    ASSERT_FALSE(ret);
    ret = ptarm_tx_verify(&sig2, txhash, PUB3);
    ASSERT_TRUE(ret);

    const uint8_t SCRIPTPK0[] = {
        0xa9, 0x14, 0xf3, 0xf0, 0xc3, 0x8f, 0x7f, 0x4b,
        0xa7, 0x02, 0x5d, 0xd7, 0x83, 0xad, 0xc3, 0x67,
        0x4f, 0xa6, 0x5b, 0x2d, 0x55, 0xbf, 0x87,
    };
    const ptarm_buf_t spk = { (uint8_t *)SCRIPTPK0, sizeof(SCRIPTPK0) };
    ret = ptarm_tx_verify_multisig(&tx, 0, txhash, PTARM_VOUT2PKH_P2SH(SCRIPTPK0));
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify_p2sh_spk(&tx, 0, txhash, &spk);
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify_p2sh_addr(&tx, 0, txhash, "2NFV4cU7qnrXo5xtbtoQ6zPwyFzdGmzbHzT");
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify_p2sh_addr(&tx, 0, txhash, "2MFV4cU7qnrXo5xtbtoQ6zPwyFzdGmzbHzT");
    ASSERT_FALSE(ret);

    ptarm_buf_free(&sig2);
    ptarm_buf_free(&sig1);
    ptarm_tx_free(&tx);
}


TEST_F(tx, sighash_p2sh_ng)
{
    //sighash_p2shとほとんど同じだが、署名の順番が逆

    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    //2-of-3
    //$ bitcoin-cli createrawtransaction '[{"txid":"89846cf0daa6ac51411e3c8ae42dec97fb0f1d8f6eb9eeb010e962b5b4bf6933","vout":0}]' '{"n2eMqTT929pb1RDNuqEnxdaLau1rxy3efi":0.007}'
    const uint8_t TX_EMPTY[] = {
        0x01, 0x00, 0x00, 0x00, 0x01, 0x33, 0x69, 0xbf,
        0xb4, 0xb5, 0x62, 0xe9, 0x10, 0xb0, 0xee, 0xb9,
        0x6e, 0x8f, 0x1d, 0x0f, 0xfb, 0x97, 0xec, 0x2d,
        0xe4, 0x8a, 0x3c, 0x1e, 0x41, 0x51, 0xac, 0xa6,
        0xda, 0xf0, 0x6c, 0x84, 0x89, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x01, 0x60,
        0xae, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19,
        0x76, 0xa9, 0x14, 0xe7, 0xc1, 0x34, 0x5f, 0xc8,
        0xf8, 0x7c, 0x68, 0x17, 0x0b, 0x3a, 0xa7, 0x98,
        0xa9, 0x56, 0xc2, 0xfe, 0x6a, 0x9e, 0xff, 0x88,
        0xac, 0x00, 0x00, 0x00, 0x00,
    };

    bool ret = ptarm_tx_read(&tx, TX_EMPTY, sizeof(TX_EMPTY));
    ASSERT_TRUE(ret);

    const uint8_t PREV_REDEEM[] = {
        0x52, 0x21, 0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64,
        0x79, 0x85, 0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50,
        0x0a, 0x9f, 0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22,
        0x7b, 0xfc, 0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a,
        0x31, 0x8f, 0xa0, 0x21, 0x03, 0x92, 0x1b, 0x52,
        0x4e, 0x16, 0xb8, 0x1c, 0x81, 0x3b, 0xaf, 0x06,
        0x2a, 0x28, 0x44, 0xff, 0x68, 0x42, 0x07, 0x3c,
        0xc0, 0xec, 0x60, 0x92, 0x31, 0xa0, 0xe3, 0x37,
        0x00, 0xdd, 0x24, 0xb5, 0xf3, 0x21, 0x03, 0x29,
        0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a, 0xef, 0x97,
        0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b, 0xe2, 0x8c,
        0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51, 0x8a, 0x88,
        0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc, 0xdc, 0x53,
        0xae,
    };
    const ptarm_buf_t redeem0 = { (uint8_t *)PREV_REDEEM, sizeof(PREV_REDEEM) };
    const ptarm_buf_t *pks[] = { &redeem0 };
    const uint8_t TXHASH[] = {
        0xc3, 0x00, 0x8f, 0x64, 0xac, 0x71, 0x05, 0x9c,
        0xd3, 0x1f, 0xaf, 0x84, 0x9c, 0x02, 0x3c, 0xc5,
        0xc9, 0xe7, 0x8d, 0x02, 0x88, 0x71, 0xc7, 0x31,
        0x84, 0x45, 0x0d, 0x0f, 0xd3, 0x3f, 0x63, 0x04,
    };
    uint8_t txhash[PTARM_SZ_HASH256];
    ret = ptarm_tx_sighash(txhash, &tx, pks, 1);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(TXHASH, txhash, PTARM_SZ_HASH256));
    ASSERT_EQ(1, tx.vin_cnt);
    ASSERT_EQ(NULL, tx.vin[0].script.buf);
    ASSERT_EQ(0, tx.vin[0].script.len);

    //
    const uint8_t PRIV1[] = {
        0x8b, 0xa9, 0x75, 0x45, 0x9f, 0xe9, 0x10, 0x67,
        0xce, 0xec, 0x41, 0xfe, 0x99, 0xd7, 0xb4, 0x2b,
        0x6b, 0x36, 0x6a, 0x4a, 0x33, 0x40, 0xf4, 0x40,
        0x66, 0xa1, 0x21, 0x68, 0x6e, 0xfc, 0x04, 0xb7,
    };
    const uint8_t PUB1[] = {
        0x03, 0x24, 0x0b, 0xc7, 0x9a, 0x64, 0x79, 0x85,
        0x1a, 0xbe, 0x77, 0x64, 0x65, 0x50, 0x0a, 0x9f,
        0xf2, 0xf8, 0x80, 0x94, 0x0b, 0x22, 0x7b, 0xfc,
        0xbc, 0xb6, 0xd4, 0x79, 0x88, 0x6a, 0x31, 0x8f,
        0xa0,
    };
//    const uint8_t PRIV2[] = {
//        0x92, 0x14, 0xfb, 0xdb, 0xb1, 0x24, 0x67, 0x7c,
//        0xb7, 0xfa, 0x6a, 0x5d, 0x84, 0x4d, 0xb8, 0x49,
//        0xde, 0x8a, 0x43, 0x15, 0x1c, 0x89, 0x68, 0x72,
//        0xd2, 0x85, 0x60, 0x73, 0x51, 0x21, 0x52, 0xd8,
//    };
    const uint8_t PUB2[] = {
        0x03, 0x92, 0x1b, 0x52, 0x4e, 0x16, 0xb8, 0x1c,
        0x81, 0x3b, 0xaf, 0x06, 0x2a, 0x28, 0x44, 0xff,
        0x68, 0x42, 0x07, 0x3c, 0xc0, 0xec, 0x60, 0x92,
        0x31, 0xa0, 0xe3, 0x37, 0x00, 0xdd, 0x24, 0xb5,
        0xf3,
    };
    const uint8_t PRIV3[] = {
        0xff, 0x63, 0x1f, 0xe7, 0x56, 0xd7, 0xdc, 0x3f,
        0x1c, 0xff, 0x88, 0xcd, 0x12, 0xfa, 0xa7, 0x08,
        0x9d, 0x1f, 0x20, 0x45, 0x21, 0x98, 0xe7, 0x77,
        0x03, 0xce, 0xdb, 0x09, 0x3e, 0x94, 0x0d, 0x0c,
    };
    const uint8_t PUB3[] = {
        0x03, 0x29, 0xbd, 0x4a, 0x08, 0x25, 0x0b, 0x6a,
        0xef, 0x97, 0x58, 0x1b, 0x36, 0x41, 0x2c, 0x9b,
        0xe2, 0x8c, 0x84, 0xba, 0xb7, 0x7d, 0x7a, 0x51,
        0x8a, 0x88, 0x00, 0x3a, 0x18, 0x0a, 0xfc, 0xfc,
        0xdc,
    };
    ptarm_buf_t sig1;
    ptarm_buf_t sig2;
    ret = ptarm_tx_sign(&sig1, txhash, PRIV1);
    ASSERT_TRUE(ret);
    ret = ptarm_tx_sign(&sig2, txhash, PRIV3);
    ASSERT_TRUE(ret);

    //送信可能なtxだが、使用済みTXIDなので送信確認はできない
    const ptarm_buf_t *sigs[] = { &sig2, &sig1 };   //逆
    const ptarm_buf_t redeem = { (uint8_t *)PREV_REDEEM, sizeof(PREV_REDEEM) };
    ret = ptarm_tx_set_vin_p2sh(&tx, 0, sigs, 2, &redeem);
    ASSERT_TRUE(ret);
    ptarm_buf_t txall;
    ptarm_tx_create(&txall, &tx);
    printf("P2SH tx=\n");
    tx::DumpBin(txall.buf, txall.len);
    ptarm_buf_free(&txall);

//    printf("priv1= ");
//    tx::DumpBin(PRIV1, sizeof(PRIV1));
//    printf("pub1= ");
//    tx::DumpBin(PUB1, sizeof(PUB1));
//    printf("priv2= ");
//    tx::DumpBin(PRIV2, sizeof(PRIV2));
//    printf("pub2= ");
//    tx::DumpBin(PUB2, sizeof(PUB2));
//    printf("priv3= ");
//    tx::DumpBin(PRIV3, sizeof(PRIV3));
//    printf("pub3= ");
//    tx::DumpBin(PUB3, sizeof(PUB3));

    //verify
    ret = ptarm_tx_verify(&sig1, txhash, PUB1);
    ASSERT_TRUE(ret);
    ret = ptarm_tx_verify(&sig2, txhash, PUB2);
    ASSERT_FALSE(ret);
    ret = ptarm_tx_verify(&sig2, txhash, PUB3);
    ASSERT_TRUE(ret);

    const uint8_t SCRIPTPK0[] = {
        0xa9, 0x14, 0xf3, 0xf0, 0xc3, 0x8f, 0x7f, 0x4b,
        0xa7, 0x02, 0x5d, 0xd7, 0x83, 0xad, 0xc3, 0x67,
        0x4f, 0xa6, 0x5b, 0x2d, 0x55, 0xbf, 0x87,
    };
    ret = ptarm_tx_verify_multisig(&tx, 0, txhash, PTARM_VOUT2PKH_P2SH(SCRIPTPK0));
    ASSERT_FALSE(ret);

    ptarm_buf_free(&sig2);
    ptarm_buf_free(&sig1);
    ptarm_tx_free(&tx);
}


TEST_F(tx, create_vout_p2pkh)
{
    bool ret;

    const char ADDR1[] = "mtpMVtHwZdpxupdmhP2A5mrxLqq97ePMLE";
    const uint8_t SCRPK1[] = {
        0x76, 0xa9, 0x14, 0x91, 0xe4, 0x13, 0x85, 0x2e,
        0x37, 0x27, 0x3e, 0xaf, 0x89, 0xda, 0xb2, 0x3a,
        0x0a, 0x21, 0xd5, 0x10, 0x82, 0x1f, 0xc0, 0x88,
        0xac,
    };

    ptarm_buf_t scr;
    ret = ptarm_tx_create_vout_p2pkh(&scr, ADDR1);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(SCRPK1, scr.buf, sizeof(SCRPK1)));
    ASSERT_EQ(sizeof(SCRPK1), scr.len);
    ptarm_buf_free(&scr);


    const char ADDR2[] = "2N9J6uZssXpQJkiSVR5v4hbNimcLnQtGjrm";
    ret = ptarm_tx_create_vout_p2pkh(&scr, ADDR2);
    ASSERT_FALSE(ret);
}


TEST_F(tx, tx_sighash)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);
    const uint8_t TX[] = {
        0x02, 0x00, 0x00, 0x00, 0x01, 0x85, 0x17, 0x66,
        0x96, 0x7f, 0xf2, 0xe1, 0xaa, 0xf6, 0x53, 0x83,
        0x40, 0x38, 0x17, 0x2f, 0xbf, 0x14, 0x57, 0x33,
        0x2e, 0x14, 0xf8, 0x4f, 0x52, 0x92, 0xbc, 0x6f,
        0x5e, 0xd2, 0x2b, 0xfe, 0x25, 0x00, 0x00, 0x00,
        0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x76,
        0xaa, 0x05, 0xa9, 0x58, 0xa1, 0x19, 0x05, 0xe9,
        0xeb, 0xe3, 0x25, 0xbc, 0x72, 0x2d, 0xfc, 0xa1,
        0x33, 0x3d, 0x6a, 0xee, 0xad, 0xa1, 0x28, 0x3f,
        0xb2, 0x1f, 0x71, 0x7d, 0xdf, 0x91, 0x8d, 0x02,
        0x20, 0x69, 0xaa, 0x7b, 0xa4, 0x85, 0xe2, 0x68,
        0xbf, 0xb4, 0x93, 0xa4, 0x01, 0xd2, 0x66, 0x14,
        0xff, 0x30, 0xa2, 0xbb, 0x2a, 0x4b, 0x9c, 0x38,
        0xba, 0x60, 0x33, 0x0e, 0xc1, 0x3e, 0x77, 0x8d,
        0xf4, 0x01, 0x21, 0x03, 0xfe, 0x21, 0x5f, 0xec,
        0x6d, 0xf4, 0x55, 0xb4, 0xb4, 0x78, 0x1e, 0xec,
        0x14, 0x49, 0xdc, 0xae, 0x32, 0x02, 0x2f, 0x62,
        0x96, 0x20, 0x2d, 0x3c, 0x46, 0x5b, 0xb0, 0x3e,
        0x46, 0xba, 0x6e, 0x91, 0xff, 0xff, 0xff, 0xff,
        0x01, 0xed, 0xeb, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x19, 0x76, 0xa9, 0x14, 0x3d, 0x5f, 0x8b,
        0x3b, 0xf9, 0x7c, 0xde, 0x12, 0x31, 0xd1, 0xcb,
        0x05, 0x49, 0xb9, 0xd0, 0x92, 0x47, 0x12, 0x98,
        0x97, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00,
    };
    bool ret = ptarm_tx_read(&tx, TX, sizeof(TX));
    ASSERT_TRUE(ret);

    const uint8_t SIGHASH[] = {
        0x77, 0xd9, 0xf2, 0x64, 0x85, 0x17, 0x99, 0xa4,
        0x57, 0x74, 0xdd, 0x3c, 0x11, 0x42, 0xa9, 0x21,
        0x4a, 0xb2, 0xc0, 0x56, 0x7d, 0xf5, 0x83, 0x76,
        0xa7, 0xd6, 0x39, 0x46, 0x11, 0x7c, 0xf7, 0x33,
    };
    const uint8_t SCRIPTSIG[] = {
        0x47, 0x30, 0x44, 0x02, 0x20, 0x76, 0xaa,
        0x05, 0xa9, 0x58, 0xa1, 0x19, 0x05, 0xe9, 0xeb,
        0xe3, 0x25, 0xbc, 0x72, 0x2d, 0xfc, 0xa1, 0x33,
        0x3d, 0x6a, 0xee, 0xad, 0xa1, 0x28, 0x3f, 0xb2,
        0x1f, 0x71, 0x7d, 0xdf, 0x91, 0x8d, 0x02, 0x20,
        0x69, 0xaa, 0x7b, 0xa4, 0x85, 0xe2, 0x68, 0xbf,
        0xb4, 0x93, 0xa4, 0x01, 0xd2, 0x66, 0x14, 0xff,
        0x30, 0xa2, 0xbb, 0x2a, 0x4b, 0x9c, 0x38, 0xba,
        0x60, 0x33, 0x0e, 0xc1, 0x3e, 0x77, 0x8d, 0xf4,
        0x01, 0x21, 0x03, 0xfe, 0x21, 0x5f, 0xec, 0x6d,
        0xf4, 0x55, 0xb4, 0xb4, 0x78, 0x1e, 0xec, 0x14,
        0x49, 0xdc, 0xae, 0x32, 0x02, 0x2f, 0x62, 0x96,
        0x20, 0x2d, 0x3c, 0x46, 0x5b, 0xb0, 0x3e, 0x46,
        0xba, 0x6e, 0x91,
    };
    const uint8_t SCRIPTPK[] = {
        0x76, 0xa9, 0x14, 0x46, 0x2c, 0xf6, 0x40, 0xfc,
        0xb6, 0x54, 0x40, 0xf8, 0x6c, 0x6a, 0x10, 0xea,
        0x7c, 0x9e, 0x74, 0x94, 0x1e, 0x69, 0x95, 0x88,
        0xac,
    };
    const ptarm_buf_t scriptpk0 = { (uint8_t *)SCRIPTPK, sizeof(SCRIPTPK) };
    const ptarm_buf_t *pks[] = { &scriptpk0 };
    uint8_t sighash[PTARM_SZ_SIGHASH];
    ret = ptarm_tx_sighash(sighash, &tx, pks, 1);
    ASSERT_TRUE(ret);
    ASSERT_EQ(0, memcmp(SIGHASH, sighash, PTARM_SZ_HASH256));
    ASSERT_EQ(1, tx.vin_cnt);
    //元に戻っていることの確認
    ASSERT_EQ(0, memcmp(tx.vin[0].script.buf, SCRIPTSIG, sizeof(SCRIPTSIG)));
    ASSERT_EQ(sizeof(SCRIPTSIG), tx.vin[0].script.len);
    ptarm_tx_free(&tx);
}


TEST_F(tx, tx_sighash2)
{
    ptarm_tx_t tx;
    ptarm_tx_init(&tx);

    const uint8_t TXID1[] = {
        0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3,
    };
    const uint8_t TXID2[] = {
        2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5,
    };
    ptarm_tx_add_vin(&tx, TXID1, 5);
    ptarm_tx_add_vin(&tx, TXID2, 10);

    const uint8_t SC1[] = {
        6, 7, 8
    };
    const uint8_t SC2[] = {
        9, 10, 11
    };
    ptarm_buf_alloccopy(&tx.vin[0].script, SC1, sizeof(SC1));
    ptarm_buf_alloccopy(&tx.vin[1].script, SC2, sizeof(SC2));
    ASSERT_EQ(0, memcmp(tx.vin[0].script.buf, SC1, sizeof(SC1)));
    ASSERT_EQ(sizeof(SC1), tx.vin[0].script.len);
    ASSERT_EQ(0, memcmp(tx.vin[1].script.buf, SC2, sizeof(SC2)));
    ASSERT_EQ(sizeof(SC2), tx.vin[1].script.len);

    const uint8_t SCRIPTPK0[] = {
        12, 13, 14, 15, 16
    };
    const uint8_t SCRIPTPK1[] = {
        17
    };
    const ptarm_buf_t scriptpk0 = { (uint8_t *)SCRIPTPK0, sizeof(SCRIPTPK0) };
    const ptarm_buf_t scriptpk1 = { (uint8_t *)SCRIPTPK1, sizeof(SCRIPTPK1) };
    const ptarm_buf_t *pks[] = { &scriptpk0, &scriptpk1 };

    uint8_t sighash[PTARM_SZ_SIGHASH];
    bool ret = ptarm_tx_sighash(sighash, &tx, pks, 2);
    ASSERT_TRUE(ret);
    ASSERT_EQ(2, tx.vin_cnt);

    //元に戻っていることの確認
    ASSERT_EQ(0, memcmp(tx.vin[0].script.buf, SC1, sizeof(SC1)));
    ASSERT_EQ(sizeof(SC1), tx.vin[0].script.len);
    ASSERT_EQ(0, memcmp(tx.vin[1].script.buf, SC2, sizeof(SC2)));
    ASSERT_EQ(sizeof(SC2), tx.vin[1].script.len);
    ptarm_tx_free(&tx);
}

