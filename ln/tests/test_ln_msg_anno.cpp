#include "gtest/gtest.h"
#include <string.h>
#include "tests/fff.h"
DEFINE_FFF_GLOBALS;


extern "C" {
#include "../../utl/utl_log.c"
#undef LOG_TAG
#include "../../utl/utl_dbg.c"
#include "../../utl/utl_buf.c"
#include "../../utl/utl_push.c"
#include "../../utl/utl_time.c"
#include "../../utl/utl_int.c"
#include "../../utl/utl_str.c"

#undef LOG_TAG
#include "../../btc/btc.c"
// #include "../../btc/btc_buf.c"
// #include "../../btc/btc_extkey.c"
// #include "../../btc/btc_keys.c"
// #include "../../btc/btc_sw.c"
//#include "../../btc/btc_sig.c"
// #include "../../btc/btc_script.c"
// #include "../../btc/btc_tx.c"
// #include "../../btc/btc_tx_buf.c"
#include "../../btc/btc_crypto.c"
// #include "../../btc/segwit_addr.c"
// #include "../../btc/btc_segwit_addr.c"
// #include "../../btc/btc_test_util.c"

#undef LOG_TAG
#include "ln_msg_anno.c"
#include "ln_misc.c"
//#include "ln_node.c"
#include "ln.c"
}

////////////////////////////////////////////////////////////////////////
//FAKE関数

FAKE_VALUE_FUNC(bool, ln_node_search_nodeid, uint8_t *, uint64_t );
FAKE_VALUE_FUNC(bool, ln_node_sign_nodekey, uint8_t *, const uint8_t *);
FAKE_VOID_FUNC(ln_node_term);


//< 32: chain-hash
static const uint8_t GENESIS_TESTNET[] = {
    // bitcoin testnet
    0x43, 0x49, 0x7f, 0xd7, 0xf8, 0x26, 0x95, 0x71,
    0x08, 0xf4, 0xa3, 0x0f, 0xd9, 0xce, 0xc3, 0xae,
    0xba, 0x79, 0x97, 0x20, 0x84, 0xe9, 0x0e, 0xad,
    0x01, 0xea, 0x33, 0x09, 0x00, 0x00, 0x00, 0x00,
};

////////////////////////////////////////////////////////////////////////

class ln: public testing::Test {
protected:
    virtual void SetUp() {
        //utl_log_init_stderr();
        utl_dbg_malloc_cnt_reset();
        btc_init(BTC_TESTNET, true);
        memcpy(gGenesisChainHash, GENESIS_TESTNET, sizeof(GENESIS_TESTNET));
        ln_node_sign_nodekey_fake.return_val = true;
    }

    virtual void TearDown() {
        ln_node_term();
        btc_term();
        ASSERT_EQ(0, utl_dbg_malloc_cnt());
    }

public:
    static void DumpBin(const uint8_t *pData, uint16_t Len)
    {
        for (uint16_t lp = 0; lp < Len; lp++) {
            printf("%02x", pData[lp]);
        }
        printf("\n");
    }
    static bool DumpCheck(const void *pData, uint32_t Len, uint8_t Fill)
    {
        bool ret = true;
        const uint8_t *p = (const uint8_t *)pData;
        for (uint32_t lp = 0; lp < Len; lp++) {
            if (p[lp] != Fill) {
                ret = false;
                break;
            }
        }
        return ret;
    }
};

////////////////////////////////////////////////////////////////////////

// no option_channel_htlc_max
TEST_F(ln, cnl_update_create_1)
{
    utl_buf_t buf_bolt = UTL_BUF_INIT;

    const uint8_t PROTO[] = {
        // channel_update
        0x01, 0x02,

        // signature
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // bitcoin testnet
        0x43, 0x49, 0x7f, 0xd7, 0xf8, 0x26, 0x95, 0x71,
        0x08, 0xf4, 0xa3, 0x0f, 0xd9, 0xce, 0xc3, 0xae,
        0xba, 0x79, 0x97, 0x20, 0x84, 0xe9, 0x0e, 0xad,
        0x01, 0xea, 0x33, 0x09, 0x00, 0x00, 0x00, 0x00,
        //        [8:short_channel_id]
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        //        [4:timestamp]
        0x23, 0x45, 0x67, 0x89,
        //        [1:message_flags]
        0x00,
        //        [1:channel_flags]
        0x00,
        //        [2:cltv_expiry_delta]
        0x45, 0x67,
        //        [8:htlc_minimum_msat]
        0x0f, 0xed, 0xcb, 0xa9, 0x87, 0x65, 0x43, 0x21,
        //        [4:fee_base_msat]
        0x39, 0x13, 0xd3, 0x2a,
        //        [4:fee_proportional_millionths]
        0x94, 0x32, 0xbb, 0x33,
        //        [8:htlc_maximum_msat] (option_channel_htlc_max)
    };

    ln_cnl_update_t upd;
    memset(&upd, 0xcc, sizeof(upd));
    upd.short_channel_id = (uint64_t)0x123456789abcdef0;
    upd.htlc_minimum_msat = (uint64_t)0x0fedcba987654321;
    upd.htlc_maximum_msat = (uint64_t)0x6af6234af91b5a3c;
    upd.timestamp = 0x23456789;
    upd.fee_base_msat = 0x3913d32a;
    upd.fee_prop_millionths = 0x9432bb33;
    upd.cltv_expiry_delta = 0x4567;
    upd.message_flags = 0x00;
    upd.channel_flags = 0x00;

    bool ret = ln_msg_cnl_update_write(&buf_bolt, &upd);
    ASSERT_TRUE(ret);
    ASSERT_EQ(sizeof(PROTO), buf_bolt.len);
    ASSERT_EQ(0, memcmp(PROTO, buf_bolt.buf, 2));
    ASSERT_EQ(0, memcmp(PROTO + 2 + 64, buf_bolt.buf + 2 + 64, sizeof(PROTO) - (2 + 64)));

    utl_buf_free(&buf_bolt);
}


// option_channel_htlc_max
TEST_F(ln, cnl_update_create_2)
{
    utl_buf_t buf_bolt = UTL_BUF_INIT;

    const uint8_t PROTO[] = {
        // channel_update
        0x01, 0x02,

        // signature
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // bitcoin testnet
        0x43, 0x49, 0x7f, 0xd7, 0xf8, 0x26, 0x95, 0x71,
        0x08, 0xf4, 0xa3, 0x0f, 0xd9, 0xce, 0xc3, 0xae,
        0xba, 0x79, 0x97, 0x20, 0x84, 0xe9, 0x0e, 0xad,
        0x01, 0xea, 0x33, 0x09, 0x00, 0x00, 0x00, 0x00,
        //        [8:short_channel_id]
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        //        [4:timestamp]
        0x23, 0x45, 0x67, 0x89,
        //        [1:message_flags]
        0x01,
        //        [1:channel_flags]
        0x00,
        //        [2:cltv_expiry_delta]
        0x45, 0x67,
        //        [8:htlc_minimum_msat]
        0x0f, 0xed, 0xcb, 0xa9, 0x87, 0x65, 0x43, 0x21,
        //        [4:fee_base_msat]
        0x39, 0x13, 0xd3, 0x2a,
        //        [4:fee_proportional_millionths]
        0x94, 0x32, 0xbb, 0x33,
        //        [8:htlc_maximum_msat] (option_channel_htlc_max)
        0x6a, 0xf6, 0x23, 0x4a, 0xf9, 0x1b, 0x5a, 0x3c,
    };

    ln_cnl_update_t upd;
    memset(&upd, 0xcc, sizeof(upd));
    upd.short_channel_id = (uint64_t)0x123456789abcdef0;
    upd.htlc_minimum_msat = (uint64_t)0x0fedcba987654321;
    upd.htlc_maximum_msat = (uint64_t)0x6af6234af91b5a3c;
    upd.timestamp = 0x23456789;
    upd.fee_base_msat = 0x3913d32a;
    upd.fee_prop_millionths = 0x9432bb33;
    upd.cltv_expiry_delta = 0x4567;
    upd.message_flags = 0x01;
    upd.channel_flags = 0x00;

    bool ret = ln_msg_cnl_update_write(&buf_bolt, &upd);
    ASSERT_TRUE(ret);
    ASSERT_EQ(sizeof(PROTO), buf_bolt.len);
    ASSERT_EQ(0, memcmp(PROTO, buf_bolt.buf, 2));
    ASSERT_EQ(0, memcmp(PROTO + 2 + 64, buf_bolt.buf + 2 + 64, sizeof(PROTO) - (2 + 64)));

    utl_buf_free(&buf_bolt);
}

////////////////////////////////////////////////////////////////////////

// no option_channel_htlc_max
TEST_F(ln, recv_cnl_update_1)
{
    const uint8_t PROTO[] = {
        // channel_update
        0x01, 0x02,

        // signature
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // bitcoin testnet
        0x43, 0x49, 0x7f, 0xd7, 0xf8, 0x26, 0x95, 0x71,
        0x08, 0xf4, 0xa3, 0x0f, 0xd9, 0xce, 0xc3, 0xae,
        0xba, 0x79, 0x97, 0x20, 0x84, 0xe9, 0x0e, 0xad,
        0x01, 0xea, 0x33, 0x09, 0x00, 0x00, 0x00, 0x00,
        //        [8:short_channel_id]
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        //        [4:timestamp]
        0x23, 0x45, 0x67, 0x89,
        //        [1:message_flags]
        0x00,
        //        [1:channel_flags]
        0x00,
        //        [2:cltv_expiry_delta]
        0x45, 0x67,
        //        [8:htlc_minimum_msat]
        0x0f, 0xed, 0xcb, 0xa9, 0x87, 0x65, 0x43, 0x21,
        //        [4:fee_base_msat]
        0x39, 0x13, 0xd3, 0x2a,
        //        [4:fee_proportional_millionths]
        0x94, 0x32, 0xbb, 0x33,
        //        [8:htlc_maximum_msat] (option_channel_htlc_max)
    };

    ln_cnl_update_t upd;
    memset(&upd, 0xcc, sizeof(upd));
    bool ret = ln_msg_cnl_update_read(&upd, PROTO, sizeof(PROTO));
    ASSERT_TRUE(ret);
    ASSERT_EQ((uint64_t)0x123456789abcdef0, upd.short_channel_id);
    ASSERT_EQ((uint64_t)0x0fedcba987654321, upd.htlc_minimum_msat);
    ASSERT_EQ((uint64_t)0, upd.htlc_maximum_msat);
    ASSERT_EQ(0x23456789, upd.timestamp);
    ASSERT_EQ(0x3913d32a, upd.fee_base_msat);
    ASSERT_EQ(0x9432bb33, upd.fee_prop_millionths);
    ASSERT_EQ(0x4567, upd.cltv_expiry_delta);
    ASSERT_EQ(0x00, upd.message_flags);
    ASSERT_EQ(0x00, upd.channel_flags);
}


// option_channel_htlc_max
TEST_F(ln, recv_cnl_update_2)
{
    const uint8_t PROTO[] = {
        // channel_update
        0x01, 0x02,

        // signature
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // bitcoin testnet
        0x43, 0x49, 0x7f, 0xd7, 0xf8, 0x26, 0x95, 0x71,
        0x08, 0xf4, 0xa3, 0x0f, 0xd9, 0xce, 0xc3, 0xae,
        0xba, 0x79, 0x97, 0x20, 0x84, 0xe9, 0x0e, 0xad,
        0x01, 0xea, 0x33, 0x09, 0x00, 0x00, 0x00, 0x00,
        //        [8:short_channel_id]
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        //        [4:timestamp]
        0x23, 0x45, 0x67, 0x89,
        //        [1:message_flags]
        0x01,
        //        [1:channel_flags]
        0x00,
        //        [2:cltv_expiry_delta]
        0x45, 0x67,
        //        [8:htlc_minimum_msat]
        0x0f, 0xed, 0xcb, 0xa9, 0x87, 0x65, 0x43, 0x21,
        //        [4:fee_base_msat]
        0x39, 0x13, 0xd3, 0x2a,
        //        [4:fee_proportional_millionths]
        0x94, 0x32, 0xbb, 0x33,
        //        [8:htlc_maximum_msat] (option_channel_htlc_max)
        0x6a, 0xf6, 0x23, 0x4a, 0xf9, 0x1b, 0x5a, 0x3c,
    };

    ln_cnl_update_t upd;
    memset(&upd, 0xcc, sizeof(upd));
    bool ret = ln_msg_cnl_update_read(&upd, PROTO, sizeof(PROTO));
    ASSERT_TRUE(ret);
    ASSERT_EQ((uint64_t)0x123456789abcdef0, upd.short_channel_id);
    ASSERT_EQ((uint64_t)0x0fedcba987654321, upd.htlc_minimum_msat);
    ASSERT_EQ((uint64_t)0x6af6234af91b5a3c, upd.htlc_maximum_msat);
    ASSERT_EQ(0x23456789, upd.timestamp);
    ASSERT_EQ(0x3913d32a, upd.fee_base_msat);
    ASSERT_EQ(0x9432bb33, upd.fee_prop_millionths);
    ASSERT_EQ(0x4567, upd.cltv_expiry_delta);
    ASSERT_EQ(0x01, upd.message_flags);
    ASSERT_EQ(0x00, upd.channel_flags);
}
